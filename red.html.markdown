---
name: Red
category: language
language: Red
filename: learnred.red
contributors:
    - ["Arnold van Hofwegen", "https://github.com/iArnold"]
translators:
    - ["Fadis F.", "https://github.com/Fadis-Fairushin"]
lang: ru-ru
---

Red был создан из-за необходимости выполнить работу, и инструмент, который автор хотел использовать, язык REBOL, имел пару недостатков.
В то время у него не было открытого исходного кода, и это интерпретируемый язык, что означает, что он в среднем медленный по сравнению с компилируемым языком.

Red, вместе со своим диалектом уровня C Red /System, предоставляет язык, который охватывает все пространство программирования, на котором вам когда-либо понадобится что-либо программировать.
Red - это язык, в значительной степени основанный на языке REBOL. Там, где сам Red воспроизводит гибкость языка REBOL, базовый язык, на котором будет построен Red,
Red /System, удовлетворяет более базовые потребности программирования, такие как C can, будучи ближе к железу.

Red станет первым в мире полнотекстовым языком программирования. Это означает, что это будет эффективный инструмент для выполнения (почти) любой задачи программирования на всех уровнях
от низкого уровня до метапрограммирования без помощи других инструментов стека.
Кроме того, Red сможет кросс-компилировать исходный код Red без использования какой-либо GCC-подобной цепочки инструментов
с любой платформы на любую другую платформу. И все это он сделает из двоичного исполняемого файла, размер которого должен составлять менее 1 МБ.

Готовы выучить свой первый красный?

```
Весь текст перед заголовком будет рассматриваться как комментарий, при условии, что вы не
будете использовать слово "Red", начинающееся с заглавной буквы "R" в этом тексте перед заголовком.
Это временный недостаток используемого лексера, но большую часть времени вы
запускаете свой скрипт или программу с самого заголовка.

Заголовок сценария red - это слово "red", написанное с заглавной буквы, за которым следует символ
пробела, за которым следует блок квадратных скобок []. Блок из
скобки могут быть заполнены полезной информацией об этом скрипте или программе:
имя автора, имя файла, версия, лицензия, краткое описание того, что
делает программа, или любые другие файлы, которые ей нужны. Заголовок red/System
точно такой же, как и заголовок red, только с надписью "red/System", а не "red"..
```
```red
Red []

; это комментарий

print "Привет, Red мир" ; второй комментарий

comment {
    Это многострочный комментарий.
    Вы только что видели красную версию программы "Hello World".
}

; Точкой входа вашей программы является первый найденный исполняемый код
; нет необходимости ограничивать это "main" функцией.

; Допустимые имена переменных начинаются с буквы и могут содержать цифры
; переменные, содержащие только заглавные буквы от A до F и цифры, заканчивающиеся на "h"
; запрещены, потому что именно так шестнадцатеричные числа выражаются в Red
; и Red/System.

; присваиваем значение переменной с помощью двоеточия ":"
my-name: "Red"
reason-for-using-the-colon: {Присвоение значений с помощью двоеточия делает
знак равенства "=" пригодным исключительно для целей сравнения,
именно для этого "=" и предназначался в первую очередь!
Помните эти школьные штучки про y = x + 1 и x = 1 => y = 2?
}
is-this-name-valid?: true

; вывод на печать с использованием print или prin для печати без перевода строки
; в конце печатаемого текста.

prin "Моё имя " print my-name
Моё имя Red

print ["Моё имя " my-name lf]
Моё имя Red

; Если вы еще не заметили: инструкции не заканчиваются точкой с запятой ;-)

;
; Типы данных
;
; ; Если вы знаете Rebol, вы, вероятно, заметили, что в нем много типов данных. Red
; еще не имеет всех этих типов, но поскольку Red хочет быть близок к Rebol, у него
; будет много типов данных.
; Вы можете распознавать типы по восклицательному знаку в конце. Но будьте осторожны
; имена, заканчивающиеся восклицательным знаком, разрешены.
; Некоторые из доступных типов являются integer! string! block!

; Объявлять переменные перед их использованием?
; Red сам знает, какую переменную лучше всего использовать для данных, для которых вы хотите
; ее использовать.
; Объявление переменной не всегда является необходимым.
; Хорошей практикой кодирования считается объявление ваших переменных,
; но Red не навязывает вам это.
; Вы можете объявить переменную и указать ее тип. тип переменной
; определяет ее размер в байтах.

; Переменные целого числа! тип обычно составляет 4 байта или 32 бита
my-integer: 0
; Целые числа Red имеют знак. Нет поддержки неподписанного atm, но это придет.

; Чтобы узнать тип переменной, используйте type?
type? my-integer
integer!

; Переменная может быть инициализирована с помощью другой переменной, которая инициализируется
; в то же время. Инициализация здесь относится как к объявлению переменной, так и
к присвоению ей значения.
i2: 1 + i1: 1

; Арифметика проста
i1 + i2 ; результат 3
i2 - i1 ; результат 1
i2 * i1 ; результат 2
i1 / i2 ; результат 0 (0.5, но усеченный в сторону 0)

; Операторы сравнения, вероятно, знакомы и непохожи на другие языки
; для сравнения вам нужен только один знак '='. Неравенство - это "<>", как в Pascal.
; Красным цветом выделен логический тип, подобный. Он имеет значения true и false, но также
; можно использовать значения on/off или yes/no

3 = 2 ; результат false
3 <> 2 ; результат true
3 > 2 ; результат true
3 < 2 ; результат false
2 <= 2 ; результат true
2 >= 2 ; результат true

;
; Управляющие структуры
;
; if
; Вычисляют блок кода, если заданное условие истинно. IF возвращает
; результирующее значение блока или 'none', если условие было ложным.
if a < 0 [print "a отрицательный"]

; either
; Вычислите блок кода, если данное условие истинно, либо вычислите
; альтернативный блок кода. Если последние выражения в обоих блоках имеют один и тот
; же тип, то любое из них может быть использовано внутри выражения.
either a > 0 [
   msg: "положительный"
][
   either a = 0 [
       msg: "ноль"
   ][
       msg: "отрицательный"
   ]
]

print ["a это " msg lf]

; Существует альтернативный способ написать это
; (Который разрешен, поскольку все пути к коду возвращают значение одного и того же типа):

msg: either a > 0 [
   "положительный"
][
   either a = 0 [
       "ноль"
   ][
       "отрицательный"
   ]
]
print ["a это " msg lf]

; until
; Цикл над блоком кода до тех пор, пока не будет выполнено условие в конце блока.
; UNTIL всегда возвращает значение 'true' из окончательной оценки последнего выражения.
c: 5
until [
   prin "o"
   c: c - 1
   c = 0    ; условие для завершения цикла until
]
; выведет:
ooooo
; Обратите внимание, что цикл всегда будет вычисляться по крайней мере один раз, даже если
; условие не выполняется с самого начала.

; while
; Пока выполняется заданное условие, вычислите блок кода.
; WHILE не возвращает никакого значения, поэтому его нельзя использовать в выражении.
c: 5
while [c > 0][
   prin "o"
   c: c - 1
]
; выведет:
ooooo

;
; Функция
;
; Пример функции
twice: function [a [integer!] /one return: [integer!]][
        c: 2
        a: a * c
        either one [a + 1][a]
]
b: 3
print twice b   ; выведет 6.

; Импортируйте внешние файлы с помощью #include, а имена файлов начинаются со знака %.
#include %includefile.red
; Теперь можно использовать и функции из прилагаемого файла.

```

## Дальнейшее чтение

Основным источником информации о Red является [Домашняя страница Red](http://www.red-lang.org).

Источник можно найти на [github](https://github.com/red/red).

Спецификацию Red/System language можно найти [здесь](http://static.red-lang.org/red-system-specs-light.html).

Чтобы узнать больше о Rebol и Red, присоединяйтесь к [чату на Gitter](https://gitter.im/red/red). И если у вас это не работает, отправьте нам письмо в [Red список рассылки](mailto: red-langNO_SPAM@googlegroups.com) (remove NO_SPAM).

Просматривайте или задавайте вопросы на [Stack Overflow](https://stackoverflow.com/questions/tagged/red).

Может быть, вы хотите попробовать красное прямо сейчас? Это возможно на сайте [попробуйте Rebol и Red](http://tryrebol.esperconsultancy.nl).

Вы также можете выучить Red, изучив некоторые [Rebol](http://www.rebol.com/docs.html).
