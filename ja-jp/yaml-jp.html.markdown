---
language: yaml
filename: learnyaml-jp.yaml
contributors:
- [Leigh Brenecki, 'https://leigh.net.au']
- [Suhas SG, 'https://github.com/jargnar']
translators:
- [haru, 'https://haru52.com/']
lang: ja-jp
---

YAMLはデータのシリアライズ用言語で、
人間が直接読み書きしやすいようにデザインされています。

YAMLはJSONの厳格なスーパーセットで、
改行とインデントが構文的に意味を持つというPythonに似た仕様を追加しています。
しかしPythonとは異なりYAMLではインデントにタブ文字を使うことはできません。

```yaml
---  # ドキュメント開始

# YAMLのコメントはこんな感じです。

##############
# スカラー型 #
##############

# （ドキュメント全体を含む）ルートオブジェクトはマップになります。
# これは他言語における辞書型、ハッシュ、オブジェクトなどと等価です。
キー: 値
別のキー: 別の値。
数値: 100
指数表記: 1e+12
# 1 はbooleanでなく数値として解釈されます。
# もしbooleanとして解釈してほしい場合はtrueを使います
boolean: true
null値: null
スペースを 含む キー: 値
# 文字列をクォートで囲う必要がないことに注意してください。
# しかし囲うこともできます。
しかし: 'クォートで囲まれた文字列。'
'キーもクォートで囲えます。': "keyの中で ':' を使いたいときに有用です。"
シングルクォート: 'には ''1つの'' エスケープパターンがあります'
ダブルクォート: "には多くのエスケープパターンがあります：\", \0, \t, \u263A,
\x0d\x0a == \r\n, など、他にもあります。"
# UTF-8/16/32文字はエンコードされている必要があります
上付き2: \u00B2

# 複数行の文字列は（| を使う）「リテラルブロック」、
# または、（'>' を使う）「折り畳みブロック」として書くことができます
リテラルブロック: |
    この文章のブロック全体が「リテラルブロック」キーの値になり、
    改行は保持されます。

    リテラルはインデントを解除するまで続き、先頭行のインデント文字数分を
    各行のテキストの先頭から取り除きます。

        「よりインデントの深い」行はその分のインデントを保持します -
        この2行はスペース4個分インデントされます。
折り畳みスタイル: >
    この文章のブロック全体が「折り畳みスタイル」の値になります。
    しかしこちらの場合、全ての改行がスペース1個に置き換わります。

    直前のような空行は改行文字に変換されます。

        「よりインデントの深い」行も改行を保持します -
        このテキストは2行にわたって表示されます。

##################
# コレクション型 #
##################

# 入れ子を表現するにはインデントを使います。
# スペース2個のインデントが好まれます（が必須ではありません）。
入れ子のマップ:
  キー: 値
  別のキー: 別の値
  別の入れ子のマップ:
    こんにちは: こんにちは

# マップのキーは文字列である必要はありません。
0.25: 小数のキー

# 複数行オブジェクトのような複雑なキーも使用可能です。
# ? の後にスペースを入れることで複雑なキーの開始を宣言できます。
? |
  これはキーです
  複数行あります
: そしてこれがその値です

# YAMLではシーケンスを複雑なキー構文で使うこともできます
# しかし、言語パーサーによってはエラーになるかもしれません
# 例
? - マンチェスター・ユナイテッド
  - レアル・マドリード
: [2001-01-01, 2002-02-02]

# シーケンス（リストや配列と等価）はこんな感じです
# （'-' はインデントとしてカウントしてください）：
シーケンス:
  - アイテム1
  - アイテム2
  - 0.5  # シーケンスには異なる型の値を混在させられます
  - アイテム4
  - キー: 値
    別のキー: 別の値
  -
    - これはシーケンスです
    - 別のシーケンス内部
  - - - 入れ子のシーケンス表記は
      - 折り畳めます

# YAMLはJSONのスーパーセットなので、
# JSON形式のマップとシーケンスを書くこともできます：
jsonマップ: {"キー": "値"}
jsonシーケンス: [3, 2, 1, "発進"]
クォートは任意: {キー: [3, 2, 1, 発進]}

######################
# その他のYAMLの機能 #
######################

# YAMLには「アンカー」と呼ばれる便利な機能もあります。これによりコンテンツを
# ドキュメント内で簡単に複製できます。これらのキーはどちらも同じ値を持ちます：
アンカーされたコンテンツ: &anchor_name この文字列は2つのキーの値になります。
他のアンカー: *anchor_name

# アンカーは複製／継承プロパティとして使えます
ベース: &base
  名前: みんな同じ名前を持ちます

# 記号 << はマージキー言語非依存型（Merge Key Language-Independent Type）
# と呼ばれます。これは指定された1つ以上のマップの全てのキーを現在のマップに
# 挿入することを示すために使われます。

foo:
  <<: *base
  年齢: 10

bar:
  <<: *base
  年齢: 20

# fooとbarも「名前： みんな同じ名前を持ちます」を持ちます

# YAMLにはタグもあり、明示的に型を宣言できます。
明示的な文字列: !!str 0.5
# 言語特有のタグを実装したパーサーもあり、例えばPythonの複素数型が使えます。
pythonの複素数型: !!python/complex 1+2j

# YAMLの複雑なキーでは言語特有のタグも使えます
? !!python/tuple [5, 7]
: 五十七
# Python上で {(5, 7): '五十七'} として扱われます

####################
# その他のYAMLの型 #
####################

# 文字列と数値がYAMLの理解できる唯一のスカラーではありません。
# ISO形式の日付や日時リテラルもパースされます。
日時: 2001-12-15T02:59:43.1Z
スペースを含む日時: 2001-12-14 21:59:43.10 -5
日付: 2002-12-14

# !!binaryタグは文字列の実体がバイナリblobのbase64エンコード表現であることを
# 示します。
gifファイル: !!binary |
  R0lGODlhDAAMAIQAAP//9/X17unp5WZmZgAAAOfn515eXvPz7Y6OjuDg4J+fn5
  OTk6enp56enmlpaWNjY6Ojo4SEhP/++f/++f/++f/++f/++f/++f/++f/++f/+
  +f/++f/++f/++f/++f/++SH+Dk1hZGUgd2l0aCBHSU1QACwAAAAADAAMAAAFLC
  AgjoEwnuNAFOhpEMTRiggcz4BNJHrv/zCFcLiwMWYNG84BwwEeECcgggoBADs=

# YAMLにはセット型もあり、それはこんな感じです：
セット:
  ? アイテム1
  ? アイテム2
  ? アイテム3
または: {アイテム1, アイテム2, アイテム3}

# セットは値がnullのただのマップで、直前のセットは以下と等価です：
セット2:
  アイテム1: null
  アイテム2: null
  アイテム3: null

...  # ドキュメント終了
```

### 補足資料

+ [YAML公式ウェブサイト](https://yaml.org/)
+ [オンラインYAMLバリデーター](http://www.yamllint.com/)
