---
name: HDL
filename: learnhdl.hdl
contributors:
  - ["Jack Smith", "https://github.com/JSmithTech2019"]
translators:
    - ["Taeyoon Kim", "https://github.com/partrita"]
---

HDL(하드웨어 기술 언어)은 실제 회로의 구조/동작을 설명하는 데 사용되는 특수 언어입니다.

회로 설계자가 하드웨어 회로를 배선하고 제작하기 전에 회로와 논리를 시뮬레이션하는 데 사용됩니다.

HDL을 사용하면 회로 설계자가 특정 구성 요소에 연결되지 않고도 높은 수준에서 회로를 시뮬레이션할 수 있습니다.

## 기본 구성 요소 및 언어 소개---
이 프로그래밍 언어는 하드웨어 칩과 배선을 시뮬레이션하여 구축됩니다. 일반적인 프로그래밍 기능은 현재 배선 설계에 추가되는 특수 칩으로 대체됩니다. 모든 기본 칩은 자체 파일로 작성하고 현재 칩에서 사용하려면 가져와야 하지만, 원하는 만큼 자주 재사용할 수 있습니다.

```verilog
// 한 줄 주석은 두 개의 슬래시로 시작합니다.

/*
 * 여러 줄 주석은 '/*'와 'star/'를 사용하여 작성할 수 있습니다.
 * 이것들은 종종 주석으로 사용됩니다.
 *
 * 중첩될 수 없으며 첫 번째 'star/'에서 끝납니다.
 */

////////////////////////////////////////////////////
// 1. 칩 및 구성 요소
////////////////////////////////////////////////////
/*
 * 다른 언어와 달리 HDL은 파일당 개별 칩(함수)을 만듭니다.
 * 이것들은 이름, 입력 인수, 출력 인수 및 마지막으로 해당 특정 칩의 부품/논리로 정의됩니다.
 */

// 참고 CHIP은 대문자이며, 칩 이름은 대문자일 필요가 없습니다.
CHIP Ex {
    IN  a,  // 단일 비트(0 또는 1) 변수입니다.
        c[16];  // 단일 비트 값의 16비트 변수 버스입니다.

    OUT out[16],  // 16비트 변수 버스 출력입니다.
        carry;  // 단일 비트 출력 변수입니다.

    PARTS:
    // 칩의 기능적 구성 요소입니다.
}

// 줄은 세미콜론으로 끝나지만 쉼표를 사용하여 계속할 수 있습니다. 공백은 무시됩니다.



////////////////////////////////////////////////////
// 2. 입력, 출력 및 변수
////////////////////////////////////////////////////
/*
 * 변수 및 IO는 핀/와이어로 처리되며 단일 비트의 데이터(0 또는 1)를 전달할 수 있습니다.
 */

// 하드웨어는 저수준 0과 1에서 작동하며, 상수 높음 또는 낮음을 사용하려면 true 및 false라는 용어를 사용합니다.
a=false; // 이것은 0 값입니다.
b=true; // 이것은 1 값입니다.

// 입력 및 출력은 단일 비트로 정의할 수 있습니다.
IN a, b; // 두 개의 단일 비트 입력을 만듭니다.

// 각 인덱스에 단일 비트 값을 포함할 수 있는 배열 역할을 하는 버스로도 정의할 수 있습니다.
OUT c[16]; // 16비트 출력 배열을 만듭니다.

// 버스 값은 대괄호를 사용하여 액세스할 수 있습니다.
a[0] // 버스 a의 첫 번째 인덱스 값입니다.
a[0..3] // a 버스의 처음 4개 값입니다.
// 값은 전체적으로 전달될 수도 있습니다. 예를 들어 함수 foo()가 8비트 입력 버스를 사용하고 2비트 버스를 출력하는 경우:
foo(in=a[0..7], out=c); // C는 이제 2비트 내부 버스입니다.


// 참고: 내부적으로 정의된 버스는 하위 버스화할 수 없습니다!
// 이러한 요소에 액세스하려면 개별적으로 출력하거나 입력하십시오:
foo(in[0]=false, in[1..7]=a[0..6], out[0]=out1, out[1]=out2);
// 그런 다음 out1 및 out2를 설계 내의 다른 회로에 전달할 수 있습니다.



////////////////////////////////////////////////////
// 하위 시스템 결합
////////////////////////////////////////////////////
/*
 * HDL은 더 크고 복잡한 설계에 추가될 작은 "구성 요소" 칩을 사용하는 데 크게 의존합니다. 작은 구성 요소를 만든 다음 더 큰 회로에 추가하면 코드 줄 수를 줄이고 코드 재작성을 줄일 수 있습니다.
 */

// 입력 I와 K가 모두 1인지 확인하는 함수 AND를 작성하고 있습니다.
// 이 칩을 구현하기 위해 내장된 NAND 게이트를 사용하고 단일 입력을 반전시키기 위해 사용자 지정 NOT 게이트를 설계합니다.

// 먼저 부정(not) 칩을 구성합니다. 이 작업에는 내장된 논리적으로 완전한 게이트 NAND를 사용합니다.
CHIP Not {
    IN i; // Not 게이트는 단일 비트 입력만 받습니다.
    OUT o; // a의 부정 값입니다.

    PARTS:
    // 내장 칩에 입력을 추가하면 NOT 출력으로 출력을 보냅니다. 이것은 주어진 값을 효과적으로 부정합니다.
    Nand(a=i, b=i, out=o);
}

// 내장된 NAND 게이트를 사용하여 실제 하드웨어 논리 칩처럼 작동하는 NOT 게이트를 구성했습니다. 이제 이 두 게이트 기본 요소를 사용하여 AND 게이트를 구성해야 합니다.

// 두 개의 입력, 단일 출력 AND 게이트를 정의합니다:
CHIP And {
    IN i, k; // 두 개의 단일 비트 입력입니다.
    OUT o; // 하나의 단일 비트 출력입니다.

    PARTS:
    // I와 K를 nand 게이트에 삽입하고 출력을 notOut이라는 내부 와이어에 저장합니다.
    Nand(a=i,b=k,out=notOut);

    // 구성한 not 게이트를 사용하여 notOut을 반전시키고 AND 출력으로 보냅니다.
    Not(in=notOut,out=o);
}

// 쉽습니다! 이제 상위 수준 회로에서 Nand, And 및 Not 게이트를 사용할 수 있습니다.
// 이러한 저수준 구성 요소 중 다수는 HDL에 내장되어 있지만 모든 칩은 하위 모듈로 작성하여 더 큰 설계에 사용할 수 있습니다.
```

## 테스트 파일
nand2tetris 하드웨어 시뮬레이터로 작업할 때 HDL을 사용하여 작성된 칩은 테스트 및 비교 파일에 대해 처리되어 시뮬레이션된 칩의 기능을 예상 출력과 비교하여 테스트합니다. 이를 위해 테스트 파일이 하드웨어 시뮬레이터에 로드되고 시뮬레이션된 하드웨어에 대해 실행됩니다.

```verilog
// 먼저 테스트 파일이 작성된 칩이 로드됩니다.
load <chip name>.hdl

// 시뮬레이션된 칩 출력에 대한 출력 파일과 테스트할 비교 파일을 설정합니다. 또한 출력이 어떻게 보일지 지정합니다. 이 경우 두 개의 출력 열이 있으며, 각 열은 양쪽에 단일 공백으로 버퍼링되고 각 열의 중앙에 4개의 이진 값이 있습니다.
output-file <chip name>.out,
compare-to <chip name>.cmp,
output-list in%B1.4.1 out%B1.4.1;

// 그런 다음 칩에 대한 입력의 초기 값을 설정합니다. 예를 들어
set enable1 1, // 입력 enable1을 1로 설정
set enable2 0, // 입력 enable2를 0으로 설정

// 클럭은 tick 및 tock을 사용하여 테스트 파일에서도 제어됩니다. Tick은 양의 펄스이고 tock은 클럭을 0으로 되돌립니다. 클럭 사이클은 입력이나 출력에 다른 변경 없이 연속으로 여러 번 실행할 수 있습니다.
tick,
tock,

// 마지막으로 (테스트 파일에서) 첫 번째 예상 값을 출력한 다음 HDL 회로의 실제 출력의 첫 번째 줄과 비교합니다. 이 출력은 <chip name>.out 파일에서 볼 수 있습니다.
output;

// <chip name>의 예, 4비트 값을 입력으로 사용하고 해당 값에 1을 더하는 칩은 다음과 같은 테스트 코드를 가질 수 있습니다:

// 입력 값을 0000으로 설정하고, 클럭 펄스를 보내고, cmp 파일의 출력을 실제 출력과 비교합니다.
set in %B0000,
tick,
tock,
output;

// 입력 값을 0110으로 설정하고, 클럭 펄스를 보내고, cmp 파일의 출력을 실제 출력과 비교합니다.
set in %B0110,
tick,
tock,
output;

// 사례 1의 예상 출력은 0001이어야 하고 사례 2는 0111을 예상합니다. 수업을 마무리하기 전에 비교 파일에 대해 조금 더 알아보겠습니다.
```

## 비교 파일
이제 비교 파일을 살펴보겠습니다. 테스트 파일이 하드웨어 시뮬레이터에서 HDL 칩의 실제 출력과 비교하는 파일입니다!

```verilog
// 위의 <chip name> 예제와 같이 비교 파일의 구조는 다음과 같습니다.
|  in  | out  |
| 0000 | 0001 |
| 0110 | 0111 |

// 테스트 사례에 지정된 입력 값이 비교 파일의 `in` 열과 동일하고 공백 버퍼가 양쪽에 1인지 확인하십시오.

// HDL 코드의 출력이 아래 출력과 같지 않으면 테스트가 실패하고 사용자는 시뮬레이션된 칩이 올바르게 설계되지 않았음을 알게 됩니다.
|  in  | out  |
| 0000 | 0001 |
| 0110 | 0110 | // 오류! 칩이 여기에 1을 추가하지 않았습니다. 뭔가 잘못되었습니다.
```

이것은 설계자가 실제 하드웨어를 제작하기 전에 칩 논리를 시뮬레이션하고 설계의 문제를 식별할 수 있으므로 매우 유용합니다. 테스트 또는 비교 파일의 오류는 거짓 양성과 더 해로운 거짓 음성을 모두 유발할 수 있으므로 테스트 생성 뒤에 있는 논리가 건전한지 확인하십시오.


행운을 빕니다. 즐거운 코딩 되세요!

## 자료

* [Nand에서 Tetris까지](https://www.nand2tetris.org)

## 추가 자료

* [하드웨어 기술 언어](https://en.wikipedia.org/wiki/Hardware_description_language)

* [HDL 프로그래밍 기초](https://www.electronicdesign.com/products/hdl-programming-fundamentals)