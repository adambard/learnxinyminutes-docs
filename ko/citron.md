---
name: citron
filename: learncitron.ctr
contributors:
    - ["AnotherTest", ""]
translators:
    - ["Taeyoon Kim", "https://github.com/partrita"]
---

```ruby
# 주석은 '#'로 시작합니다.
# 모든 주석은 한 줄을 포함합니다.

###########################################
## 1. 기본 데이터 유형 및 연산자
###########################################

# 숫자가 있습니다.
3. # 3

# 숫자는 해석 모드에서 모두 double입니다.

# 수학 연산자 우선 순위는 존중되지 않습니다.
# 이진 '연산자'는 ltr 순서로 평가됩니다.
1 + 1. # 2
8 - 4. # 4
10 + 2 * 3. # 36

# 나눗셈은 항상 부동 소수점 나눗셈입니다.
35 / 2 # 17.5.

# 정수 나눗셈은 간단하지 않으며, floor를 사용할 수 있습니다.
(35 / 2) floor # 17.

# 부울은 기본 유형입니다.
True.
False.

# 부울 메시지
True not. # False
False not. # True
1 = 1. # True
1 !=: 1. # False
1 < 10. # True

# 여기서 `not`은 `Boolean` 객체에 대한 단항 메시지입니다.
# 메시지는 인스턴스 메서드 호출과 유사합니다.
# 그리고 세 가지 다른 형식이 있습니다:
#   1. 단항 메시지: 길이 > 1이며 인수를 받지 않습니다:
        False not.
#   2. 이진 메시지: 길이 = 1이며 단일 인수를 받습니다:
        False & True.
#   3. 키워드 메시지: 적어도 하나의 ':'가 있어야 하며, ':' 수만큼 인수를 받습니다.
        False either: 1 or: 2. # 2

# 문자열
'This is a string'.
'There are no character types exposed to the user'.
# "You cannot use double quotes for strings" <- 오류

# 문자열을 더할 수 있습니다.
'Hello, ' + 'World!'. # 'Hello, World!'

# 문자열은 문자에 액세스할 수 있습니다.
'This is a beautiful string' at: 0. # 'T'

###########################################
## 막간: 기본 할당
###########################################

# 현재 범위에 값을 할당할 수 있습니다:
var name is value. # `name`에 `value`를 할당합니다.

# 현재 객체의 네임스페이스에 값을 할당할 수도 있습니다.
my name is value. # 현재 객체의 `name` 속성에 `value`를 할당합니다.

# 이러한 이름은 컴파일(해석 모드인 경우 구문 분석 읽기) 시 확인되지만
# 동적 할당으로 처리할 수 있습니다.

###########################################
## 2. 목록(배열?) 및 튜플
###########################################

# 배열은 여러 유형을 가질 수 있습니다.
Array new < 1 ; 2 ; 'string' ; Nil. # Array new < 1 ; 2 ; 'string' ; Nil

# 튜플은 배열처럼 작동하지만 변경할 수 없습니다.
# 그러나 모든 장난은 배열로 저하시킵니다.
[1, 2, 'string']. # [1, 2, 'string']

# 배열과 상호 운용할 수 있습니다.
[1, 'string'] + (Array new < 'wat'). # Array new < 1 ; 'string' ; 'wat'

# 인덱싱
[1, 2, 3] at: 1. # 2

# 일부 배열 작업
var arr is Array new < 1 ; 2 ; 3.

arr head. # 1
arr tail. # Array new < 2 ; 3.
arr init. # Array new < 1 ; 2.
arr last. # 3
arr push: 4. # Array new < 1 ; 2 ; 3 ; 4.
arr pop. # 4
arr pop: 1. # 2, `arr`는 Array new < 1 ; 3.으로 다시 바인딩됩니다.

# 목록 이해
[x * 2 + y,, arr, arr + [4, 5],, x > 1]. # Array ← 7 ; 9 ; 10 ; 11
# 새 변수 이름은 마주칠 때 바인딩되므로
# `x`는 `arr`의 값에 바인딩되고
# `y`는 `arr + [4, 5]`의 값에 바인딩됩니다.
#
# 일반적인 형식은 다음과 같습니다: [expr,, bindings*,, predicates*]


####################################
## 3. 함수
####################################

# 두 변수를 사용하는 간단한 함수
var add is {:a:b ^a + b.}.

# 이 함수는 형식 인수를 제외한 모든 이름을
# 호출되는 컨텍스트에서 확인합니다.

# 함수 사용
add applyTo: 3 and: 5. # 8
add applyAll: [3, 5]. # 8

# 또한 (사용자 정의 가능한 -- 나중에 자세히 설명) 의사 연산자는
# 함수 호출에 대한 약어를 허용합니다.
# 기본적으로 REF[args]입니다.

add[3, 5]. # 8

# 이 동작을 사용자 정의하려면 컴파일러 프라그마를 사용하면 됩니다:
#:callShorthand ()

# 그런 다음 지정된 연산자를 사용할 수 있습니다.
# 허용되는 '연산자'는 []{}() 중 하나로만 구성될 수 있습니다.
# 그리고 혼합하여 사용할 수 있습니다(누가 그렇게 하겠습니까?).

add(3, 5). # 8

# 다음과 같은 방식으로 함수를 연산자로 사용할 수도 있습니다:

3 `add` 5. # 8
# 이 호출은 다음과 같이 바인딩됩니다: add[(3), 5]
# 기본 고정성은 왼쪽이고 기본 우선 순위는 1이기 때문입니다.

# 프라그마를 사용하여 이 연산자의 우선 순위/고정성을 변경할 수 있습니다.
#:declare infixr 1 add

3 `add` 5. # 8
# 이제 다음과 같이 바인딩됩니다: add[3, (5)].

# 또 다른 형태의 함수도 있습니다.
# 지금까지 함수는 동적 방식으로 확인되었습니다.
# 그러나 어휘적으로 범위가 지정된 블록도 가능합니다.
var sillyAdd is {\:x:y add[x,y].}.

# 이러한 블록에서는 새 변수를 선언할 수 없습니다.
# Object::'letEqual:in:`을 사용하는 경우를 제외하고
# 그리고 마지막 표현식은 암시적으로 반환됩니다.

# 람다 표현식에 대한 약어를 사용할 수도 있습니다.
var mul is \:x:y x * y.

# 이들은 형식 매개변수에 없는 명명된 바인딩을 캡처하고
# 유지합니다. (참조로)

###########################################
## 5. 제어 흐름
###########################################

# 인라인 조건 표현식
var citron is 1 = 1 either: 'awesome' or: 'awful'. # citron is 'awesome'

# 여러 줄도 괜찮습니다.
var citron is 1 = 1
    either: 'awesome'
    or:     'awful'.

# 반복
10 times: {:x
    Pen writeln: x.
}. # 10. -- 부작용: stdout에 10줄, 0부터 9까지의 숫자 포함

# Citron은 어휘적으로 범위가 지정된 블록에서 꼬리 호출 재귀를 제대로 지원합니다.
# 따라서 마음껏 사용하십시오.

# 대부분의 데이터 구조를 매핑하는 것은 `fmap:`만큼 간단합니다.
[1, 2, 3, 4] fmap: \:x x + 1. # [2, 3, 4, 5]

# `foldl:accumulator:`를 사용하여 목록/튜플을 접을 수 있습니다.
[1, 2, 3, 4] foldl: (\:acc:x acc * 2 + x) accumulator: 4. # 90

# 해당 표현식은 다음과 같습니다.
(2 * (2 * (2 * (2 * 4 + 1) + 2) + 3) + 4)

###################################
## 6. IO
###################################

# IO는 매우 간단합니다.
# `Pen`은 콘솔 출력에 사용됩니다.
# 그리고 Program::'input' 및 Program::'waitForInput'은 콘솔 입력에 사용됩니다.

Pen writeln: 'Hello, ocean!' # 터미널에 'Hello, ocean!\n'을 인쇄합니다.

Pen writeln: Program waitForInput. # 한 줄을 읽고 다시 인쇄합니다.
```