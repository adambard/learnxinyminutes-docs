---
category: tool
tool: bash
contributors:
    - ["Max Yankov", "https://github.com/golergka"]
    - ["Darren Lin", "https://github.com/CogBear"]
    - ["Alexandre Medeiros", "http://alemedeiros.sdf.org"]
    - ["Denis Arh", "https://github.com/darh"]
    - ["akirahirose", "https://twitter.com/akirahirose"]
    - ["Anton Strömkvist", "http://lutic.org/"]
    - ["Rahil Momin", "https://github.com/iamrahil"]
    - ["Gregrory Kielian", "https://github.com/gskielian"]
filename: LearnBash-ru.sh
translators:
    - ["Dmitry Bessonov", "https://github.com/TheDmitry"]
lang: ru-ru
---

Bash - это название командного процессора UNIX, который также был распространен
в качестве оболочки для операционной системы GNU, и как оболочки по умолчанию
в Linux и Mac OS X.
Почти все примеры ниже могут быть частью скрипта командной оболочки или выполнены
сразу же в командной оболочке.

[Подробнее читайте здесь.](http://www.gnu.org/software/bash/manual/bashref.html)

```bash
#!/bin/bash
# Первая строка скрипта - это знак начала сценария (shebang), который говорит
# системе как запустить скрипт: http://en.wikipedia.org/wiki/Shebang_(Unix)
# Как вы уже поняли, комментарии начинаются с #. Shebang - это тоже комментарий.

# Простой пример "Hello World":
echo Привет мир!

# Каждая команда начинается с новой строки или после точки с запятой:
echo 'Первая строка'; echo 'Вторая строка'

# Объявление переменной выглядит следующим образом:
VARIABLE="Некоторая строка"

# Но не так, как это:
VARIABLE = "Некоторая строка"
# Bash решит, что VARIABLE является командой, которую необходимо выполнить,
# но приведет к ошибке, потому что не сможет найти такую команду.

# Использование переменной:
echo $VARIABLE
echo "$VARIABLE"
echo '$VARIABLE'
# Когда вы используете переменные — определяете их, передаете их или делаете
# что-то еще — вы пишите их имя без знака $. Если вы хотите использовать значение
# переменной, вы должны использовать знак $.
# Заметьте, что ' (одинарная кавычка) не будет раскрывать переменные!

# Строковая подмена в переменных
echo ${VARIABLE/Some/A}
# Заменит первый попавшийся "Some" на "A"

# Подстрока переменной
echo ${VARIABLE:0:7}
# Вернет только первые 7 символов значения

# Значение по умолчанию для переменной
echo ${FOO:-"ЗначениеПоУмолчаниюЕслиFOOотсутствуетИлиПустой"}
# Это работает для null (FOO=), пустой строки (FOO=""), а ноль (FOO=0) вернет 0

# Встроенные переменные:
# Существуют некоторые полезные встроенные переменные подобно этим:
echo "Последнее возвращенное значение программы: $?"
echo "PID скрипта: $$"
echo "Количество аргументов: $#"
echo "Аргументы скрипта: $@"
echo "Аргументы скрипта разделенные на отдельные переменные: $1 $2..."

# Чтение значения из входного потока:
echo "Как тебя зовут?"
read NAME # Заметьте, что нам не нужно объявлять новую переменную
echo Привет, $NAME!

# У нас есть обычная if-структура:
# используйте 'man test' для дополнительной информации об условиях
if [ $NAME -ne $USER ]
then
    echo "Ваше имя отличается от пользовательского имени"
else
    echo "Ваше имя схоже с пользовательским именем"
fi

# Также имеется условное исполнение команд
echo "Всегда выполняется" || echo "Выполнится только, если первая команда завершилась с ошибкой"
echo "Всегда выполняется" && echo "Выполнится только, если первая команда завершилась без ошибок"

# Чтобы использовать && и || с if-операторами, вам необходимы
# многочисленные пары квадратных скобок:
if [ $NAME == "Стив" ] && [ $AGE -eq 15 ]
then
    echo "Выполнится, если $NAME равно Стив И $AGE равно 15."
fi

if [ $NAME == "Дания" ] || [ $NAME == "Зак" ]
then
    echo "Выполнится, если $NAME равно Дания ИЛИ Зак."
fi

# Выражения обозначаются следующим форматом:
echo $(( 10 + 5 ))

# Bash не похож на другие языки программирования, он является командным
# процессором, который работает в контексте текущей директории. Вы можете
# вывести список файлов и директорий в текущей директории с помощью команды ls:
ls

# Такие команды имеют ключи, которые управляют их выполнением:
ls -l # Выводит список каждого файла и директории на отдельной строке

# Результаты предыдущей команды могут быть переданы следующей команде,
# как входной поток. Команда grep фильтрует входной поток с помощью переданных
# шаблонах. Это способ, которым мы может вывести список .txt-файлов
# в текущей директории:
ls -l | grep "\.txt"

# Вы можете в команде перенаправить стандартные потоки ввода-вывода
# (stdin, stdout, and stderr). Читать из stdin, пока ^EOF$, и перезаписать
# hello.py строками между "EOF":
cat > hello.py << EOF
#!/usr/bin/env python
from __future__ import print_function
import sys
print("#stdout", file=sys.stdout)
print("#stderr", file=sys.stderr)
for line in sys.stdin:
    print(line, file=sys.stdout)
EOF

# Запустите hello.py с перенаправлениями различных stdin, stdout, и stderr:
python hello.py < "input.in"
python hello.py > "output.out"
python hello.py 2> "error.err"
python hello.py > "output-and-error.log" 2>&1
python hello.py > /dev/null 2>&1
# Поток вывода ошибок перезапишет файл, если он существует,
# а если вы хотите дополнить запись, воспользуйтесь ">>":
python hello.py >> "output.out" 2>> "error.err"

# Перезапишите output.txt, добавив запись в error.err, и посчитайте строки:
info bash 'Basic Shell Features' 'Redirections' > output.out 2>> error.err
wc -l output.out error.err

# Запустите команду и напечатайте ее файловый дескриптор (напр. /dev/fd/123)
# См.: man fd
echo <(echo "#helloworld")

# Перепишите файл output.txt с "#helloworld":
cat > output.out <(echo "#helloworld")
echo "#helloworld" > output.out
echo "#helloworld" | cat > output.out
echo "#helloworld" | tee output.out >/dev/null

# Подробная очистка временных файлов (добавьте ключ '-i' для режима диалога)
rm -v output.out error.err output-and-error.log

# Команды могут вставляться в другие команды с помощью $( ):
# Следующая команда отображает количество файлов и директорий в
# текущей директории.
echo "Здесь $(ls | wc -l) элементов."

# Подобное можно сделать с помощью обратных апострофов ``, но они не могут быть
# вложенными, предпочтителен способ с использованием $( ).
echo "Здесь `ls | wc -l` элементов."

# Bash использует case-оператор, который работает подобно переключателям (switch)
# в Java и C++:
case "$VARIABLE" in 
    #Список шаблонов для условий, которые вы хотите испытать
    0) echo "Это ноль.";;
    1) echo "Это один.";;
    *) echo "Это не null.";;
esac

# Цикл for повторит столько итераций, сколько передано аргументов:
# Содержимое $VARIABLE напечатается три раза.
for VARIABLE in {1..3}
do
    echo "$VARIABLE"
done

# Или напишите цикл for традиционным способом:
for ((a=1; a <= 3; a++))
do
    echo $a
done

# Они также могут произвести действия над файлами..
# Будет запущена команда 'cat' для file1 и file2
for VARIABLE in file1 file2
do
    cat "$VARIABLE"
done

# ..или вывод из команды
# Команда cat выдаст содержимое из команды ls.
for OUTPUT in $(ls)
do
    cat "$OUTPUT"
done

# Цикл while:
while [ true ]
do
    echo "Здесь тело цикла..."
    break
done

# Вы можете также определять функции
# Определение:
function foo ()
{
    echo "Аргументы работают также, как аргументы скрипта: $@"
    echo "И: $1 $2..."
    echo "Это функция"
    return 0
}

# или проще
bar ()
{
    echo "Еще один способ объявления функций!"
    return 0
}

# Вызов вашей функции
foo "Мое имя" $NAME

# Существует много полезных команд, которые вы можете изучить:
# напечатает последние 10 строк file.txt
tail -n 10 file.txt
# напечатает первые 10 строк file.txt
head -n 10 file.txt
# отсортирует строки в file.txt
sort file.txt
# сообщит или пропустит повторные строки, а с помощью ключа -d он сообщит о них
uniq -d file.txt
# напечатает только первую колонку перед символом ','
cut -d ',' -f 1 file.txt
# заменит все встречающиеся 'okay' на 'great' в file.txt, (похоже
# на регулярное выражение)
sed -i 's/okay/great/g' file.txt
# напечатает в выходной поток все строки file.txt, которые совпали с регулярным
# выражением, например напечатает строки, которые начинаются с "foo"
# и заканчиваются на "bar"
grep "^foo.*bar$" file.txt
# передайте ключ "-c", в отличие от предыдущего результата напечатает
# количество строк совпавших с регулярным выражением
grep -c "^foo.*bar$" file.txt
# если вы хотите по буквам найти строку, а не регулярное выражение,
# используйте fgrep (или grep -F)
fgrep "^foo.*bar$" file.txt 


# Читайте документацию о встроенных командах оболочки Bash
# с помощью встроенной команды 'help':
help
help help
help for
help return
help source
help .

# Читайте страницы документации о Bash с помощью man
apropos bash
man 1 bash
man bash

# Читайте информационную документацию с помощью info (? - для помощи)
apropos info | grep '^info.*('
man info
info info
info 5 info

# Читайте информационную документацию bash:
info bash
info bash 'Особенности Bash'
info bash 6
info --apropos bash
```
