---
language: python3
lang: ru-ru
contributors:
    - ["Louie Dinh", "http://ldinh.ca"]
    - ["Steven Basart", "http://github.com/xksteven"]
translators:
    - ["Andre Polykanine", "https://github.com/Oire"]
filename: learnpython3-ru.py
---

Язык Python был создан Гвидо ван Россумом в начале 90-х. Сейчас это один из
самых популярных языков. Я влюбился в Python за понятный и доходчивый синтаксис  — это
почти что исполняемый псевдокод.

С благодарностью жду ваших отзывов: [@louiedinh](http://twitter.com/louiedinh)
или louiedinh [at] [почтовый сервис Google]

Замечание: Эта статья относится только к Python 3.
Если вы хотите изучить Python 2.7, обратитесь к другой статье.

```python
# Однострочные комментарии начинаются с символа решётки.
""" Многострочный текст может быть 
    записан, используя 3 знака " и обычно используется
    в качестве встроенной документации
"""

####################################################
## 1. Примитивные типы данных и операторы
####################################################

# У вас есть числа
3 #=> 3

# Математика работает вполне ожидаемо
1 + 1 #=> 2
8 - 1 #=> 7
10 * 2 #=> 20

# Кроме деления, которое по умолчанию возвращает число с плавающей запятой
35 / 5  # => 7.0

# Результат целочисленного деления округляется в меньшую сторону
# как для положительных, так и для отрицательных чисел.
5 // 3     # => 1
5.0 // 3.0 # => 1.0 # работает и для чисел с плавающей запятой
-5 // 3  # => -2
-5.0 // 3.0 # => -2.0

# Когда вы используете числа с плавающей запятой, 
# результатом будет также число с плавающей запятой
3 * 2.0 # => 6.0

# Остаток от деления
7 % 3 # => 1

# Возведение в степень
2**4 # => 16

# Приоритет операций указывается скобками
(1 + 3) * 2 #=> 8

# Для логических (булевых) значений существует отдельный примитивный тип
True
False

# Для отрицания используется ключевое слово not
not True #=> False
not False #=> True

# Логические операторы
# Обратите внимание: ключевые слова «and» и «or» чувствительны к регистру букв
True and False #=> False
False or True #=> True

# Обратите внимание, что логические операторы используются и с целыми числами
0 and 2 #=> 0
-5 or 0 #=> -5
0 == False #=> True
2 == True #=> False
1 == True #=> True

# Равенство — это ==
1 == 1 #=> True
2 == 1 #=> False

# Неравенство — это !=
1 != 1 #=> False
2 != 1 #=> True

# Ещё немного сравнений
1 < 10 #=> True
1 > 10 #=> False
2 <= 2 #=> True
2 >= 2 #=> True

# Сравнения могут быть записаны цепочкой:
1 < 2 < 3 #=> True
2 < 3 < 2 #=> False

# Строки определяются символом " или '
"Это строка."
'Это тоже строка.'

# И строки тоже могут складываться! Хотя лучше не злоупотребляйте этим.
"Привет " + "мир!" #=> "Привет мир!"

# Со строкой можно работать, как со списком символов
"Это строка"[0] #=> 'Э'

# Метод format используется для форматирования строк:
"{0} могут быть {1}".format("строки", "форматированы")

# Вы можете повторять аргументы форматирования, чтобы меньше печатать.
"Ехал {0} через реку, видит {0} - в реке {1}! Сунул {0} руку в реку, {1} за руку греку цап!".format("грека", "рак")
#=> "Ехал грека через реку, видит грека - в реке рак! Сунул грека руку в реку, рак за руку греку цап!"
# Если вы не хотите считать, можете использовать ключевые слова.
"{name} хочет есть {food}".format(name="Боб", food="лазанью")

# Если ваш код на Python 3 нужно запускать также и под Python 2.5 и ниже,
# вы также можете использовать старый способ форматирования:
"%s можно %s %s способом" % ("строки", "интерполировать", "старым")

# None является объектом
None #=> None

# Не используйте оператор равенства '==' для сравнения 
# объектов с None. Используйте для этого 'is'
"etc" is None #=> False
None is None  #=> True

# Оператор «is» проверяет идентичность объектов. Он не 
# очень полезен при работе с примитивными типами, но 
# зато просто незаменим при работе с объектами.

# None, 0 и пустые строки/списки/словари приводятся к False.
# Все остальные значения равны True
bool(0)  # => False
bool("")  # => False
bool([]) #=> False
bool({}) #=> False


####################################################
## 2. Переменные и коллекции
####################################################

# В Python есть функция Print
print("Я Python. Приятно познакомиться!")

# Объявлять переменные перед инициализацией не нужно.
# По соглашению используется нижний_регистр_с_подчёркиваниями
some_var = 5
some_var #=> 5

# При попытке доступа к неинициализированной переменной
# выбрасывается исключение.
# Об исключениях см. раздел «Поток управления и итерируемые объекты».
some_unknown_var  # Выбрасывает ошибку именования

# Списки хранят последовательности
li = []
# Можно сразу начать с заполненного списка
other_li = [4, 5, 6]

# Объекты добавляются в конец списка методом append
li.append(1)    # [1]
li.append(2)    # [1, 2]
li.append(4)    # [1, 2, 4]
li.append(3)    # [1, 2, 4, 3]
# И удаляются с конца методом pop
li.pop()        #=> возвращает 3 и li становится равен [1, 2, 4]
# Положим элемент обратно
li.append(3)    # [1, 2, 4, 3].

# Обращайтесь со списком, как с обычным массивом
li[0] #=> 1
# Обратимся к последнему элементу
li[-1] #=> 3

# Попытка выйти за границы массива приведёт к ошибке индекса
li[4] # Выдаёт IndexError

# Можно обращаться к диапазону, используя так называемые срезы
# (Для тех, кто любит математику, это называется замкнуто-открытый интервал).
li[1:3] #=> [2, 4]
# Опускаем начало
li[2:] #=> [4, 3]
# Опускаем конец
li[:3] #=> [1, 2, 4]
# Выбираем каждый второй элемент
li[::2]   # =>[1, 4]
# Переворачиваем список
li[::-1]   # => [3, 4, 2, 1]
# Используйте сочетания всего вышеназванного для выделения более сложных срезов
# li[начало:конец:шаг]

# Удаляем произвольные элементы из списка оператором del
del li[2] # [1, 2, 3]

# Вы можете складывать, или, как ещё говорят, конкатенировать списки
# Обратите внимание: значения li и other_li при этом не изменились.
li + other_li #=> [1, 2, 3, 4, 5, 6]  — Замечание: li и other_li не изменяются

# Объединять списки можно методом extend
li.extend(other_li) # Теперь li содержит [1, 2, 3, 4, 5, 6]

# Проверить элемент на вхождение в список можно оператором in
1 in li #=> True

# Длина списка вычисляется функцией len
len(li) #=> 6


# Кортежи — это такие списки, только неизменяемые
tup = (1, 2, 3)
tup[0] #=> 1
tup[0] = 3  # Выдаёт TypeError

# Всё то же самое можно делать и с кортежами
len(tup) #=> 3
tup + (4, 5, 6) #=> (1, 2, 3, 4, 5, 6)
tup[:2] #=> (1, 2)
2 in tup #=> True

# Вы можете распаковывать кортежи (или списки) в переменные
a, b, c = (1, 2, 3)     # a == 1, b == 2 и c == 3
# Кортежи создаются по умолчанию, если опущены скобки
d, e, f = 4, 5, 6
# Обратите внимание, как легко поменять местами значения двух переменных
e, d = d, e     # теперь d == 5, а e == 4


#  Словари содержат ассоциативные массивы
empty_dict = {}
# Вот так описывается предзаполненный словарь
filled_dict = {"one": 1, "two": 2, "three": 3}

# Значения извлекаются так же, как из списка, с той лишь разницей,
# что индекс — у словарей он называется ключом — не обязан быть числом
filled_dict["one"] #=> 1

# Все ключи в виде списка получаются с помощью метода keys(). 
# Его вызов нужно обернуть в list(), так как обратно мы получаем
# итерируемый объект, о которых поговорим позднее.
list(filled_dict.keys())   # => ["three", "two", "one"]
# Замечание: сохранение порядка ключей в словаре не гарантируется
# Ваши результаты могут не совпадать с этими.

# Все значения в виде списка можно получить с помощью values().
# И снова нам нужно обернуть вызов в list(), чтобы превратить
# итерируемый объект в список.
list(filled_dict.values())   # => [3, 2, 1]
# То же самое замечание насчёт порядка ключей справедливо и здесь

# При помощи оператора in можно проверять ключи на вхождение в словарь
"one" in filled_dict #=> True
1 in filled_dict #=> False

# Попытка получить значение по несуществующему ключу выбросит ошибку ключа
filled_dict["four"] # KeyError

# Чтобы избежать этого, используйте метод get()
filled_dict.get("one") #=> 1
filled_dict.get("four") #=> None
# Метод get также принимает аргумент по умолчанию, значение которого будет
# возвращено при отсутствии указанного ключа
filled_dict.get("one", 4) #=> 1
filled_dict.get("four", 4) #=> 4

# Метод setdefault вставляет пару ключ-значение, только если такого ключа нет
filled_dict.setdefault("five", 5) #filled_dict["five"] возвращает 5
filled_dict.setdefault("five", 6) #filled_dict["five"] по-прежнему возвращает 5

# Добавление элементов в словарь
filled_dict.update({"four":4}) #=> {"one": 1, "two": 2, "three": 3, "four": 4}
#filled_dict["four"] = 4  # Другой способ добавления элементов

# Удаляйте ключи из словаря с помощью оператора del
del filled_dict["one"]  # Удаляет ключ «one» из словаря


# Множества содержат... ну, в общем, множества
empty_set = set()
# Инициализация множества набором значений.
# Да, оно выглядит примерно как словарь… ну извините, так уж вышло.
filled_set = {1, 2, 2, 3, 4} # => {1, 2, 3, 4}

# Множеству можно назначать новую переменную
filled_set = some_set

# Добавление новых элементов в множество
filled_set.add(5) # filled_set равно {1, 2, 3, 4, 5}

# Пересечение множеств: &
other_set = {3, 4, 5, 6}
filled_set & other_set #=> {3, 4, 5}

# Объединение множеств: |
filled_set | other_set #=> {1, 2, 3, 4, 5, 6}

# Разность множеств: -
{1,2,3,4} - {2,3,5} #=> {1, 4}

# Проверка на вхождение во множество: in
2 in filled_set #=> True
10 in filled_set #=> False


####################################################
## 3. Поток управления и итерируемые объекты
####################################################

# Для начала заведём переменную
some_var = 5

# Так выглядит выражение if. Отступы в python очень важны!
# результат: «some_var меньше, чем 10»
if some_var > 10:
    print("some_var намного больше, чем 10.")
elif some_var < 10:    # Выражение elif необязательно.
    print("some_var меньше, чем 10.")
else:           # Это тоже необязательно.
    print("some_var равно 10.")


# Циклы For проходят по спискам. Результат:
    # собака — это млекопитающее
    # кошка — это млекопитающее
    # мышь — это млекопитающее
for animal in ["собака", "кошка", "мышь"]:
    # Можете использовать format() для интерполяции форматированных строк
    print("{} — это млекопитающее".format(animal))
    
"""
«range(число)» возвращает список чисел
от нуля до заданного числа
Результат:
    0
    1
    2
    3
"""
for i in range(4):
    print(i)

"""
Циклы while продолжаются до тех пор, пока указанное условие не станет ложным.
Результат:
    0
    1
    2
    3
"""
x = 0
while x < 4:
    print(x)
    x += 1  # Краткая запись для x = x + 1

# Обрабатывайте исключения блоками try/except
try:
    # Чтобы выбросить ошибку, используется raise
    raise IndexError("Это ошибка индекса")
except IndexError as e:
    # pass — это просто отсутствие оператора. Обычно здесь происходит
    # восстановление после ошибки.
    pass
except (TypeError, NameError):
    pass    # Несколько исключений можно обработать вместе, если нужно.
else:   # Необязательное выражение. Должно следовать за последним блоком except
    print("Всё хорошо!")   # Выполнится, только если не было никаких исключений

# Python предоставляет фундаментальную абстракцию,
# которая называется итерируемым объектом (an iterable).
# Итерируемый объект — это объект, который воспринимается как последовательность.
# Объект, который возвратила функция range(), итерируемый.
filled_dict = {"one": 1, "two": 2, "three": 3}
our_iterable = filled_dict.keys()
print(our_iterable) #=> range(1,10). Это объект, реализующий интерфейс iterable

# Мы можем проходить по нему циклом.
for i in our_iterable:
    print(i)    # Выводит one, two, three

# Но мы не можем обращаться к элементу по индексу.
our_iterable[1]  # Выбрасывает ошибку типа

# Итерируемый объект знает, как создавать итератор.
our_iterator = iter(our_iterable)

# Итератор может запоминать состояние при проходе по объекту.
# Мы получаем следующий объект, вызывая функцию __next__.
our_iterator.__next__()  #=> "one"

# Он сохраняет состояние при вызове __next__.
our_iterator.__next__()  #=> "two"
our_iterator.__next__()  #=> "three"

# Возвратив все данные, итератор выбрасывает исключение StopIterator
our_iterator.__next__() # Выбрасывает исключение остановки итератора

# Вы можете получить сразу все элементы итератора, вызвав на нём функцию list().
list(filled_dict.keys())  #=> Возвращает ["one", "two", "three"]


####################################################
## 4. Функции
####################################################

# Используйте def для создания новых функций
def add(x, y):
    print("x равен %s, а y равен %s" % (x, y))
    return x + y    # Возвращайте результат с помощью ключевого слова return

# Вызов функции с аргументами
add(5, 6) #=> выводит «x равен 5, а y равен 6» и возвращает 11

# Другой способ вызова функции — вызов с именованными аргументами
add(y=6, x=5)   # Именованные аргументы можно указывать в любом порядке.

# Вы можете определить функцию, принимающую переменное число аргументов
def varargs(*args):
    return args

varargs(1, 2, 3) #=> (1,2,3)


# А также можете определить функцию, принимающую переменное число
# именованных аргументов
def keyword_args(**kwargs):
    return kwargs

# Вызовем эту функцию и посмотрим, что из этого получится
keyword_args(big="foot", loch="ness") #=> {"big": "foot", "loch": "ness"}

# Если хотите, можете использовать оба способа одновременно
def all_the_args(*args, **kwargs):
    print(args)
    print(kwargs)
"""
all_the_args(1, 2, a=3, b=4) выводит:
    (1, 2)
    {"a": 3, "b": 4}
"""

# Вызывая функции, можете сделать наоборот!
# Используйте символ * для распаковки кортежей и ** для распаковки словарей
args = (1, 2, 3, 4)
kwargs = {"a": 3, "b": 4}
all_the_args(*args) # эквивалентно foo(1, 2, 3, 4)
all_the_args(**kwargs) # эквивалентно foo(a=3, b=4)
all_the_args(*args, **kwargs) # эквивалентно foo(1, 2, 3, 4, a=3, b=4)

# Область определения функций
x = 5

def setX(num):
    # Локальная переменная x — это не то же самое, что глобальная переменная x
    x = num # => 43
    print (x) # => 43
    
def setGlobalX(num):
    global x
    print (x) # => 5
    x = num # Глобальная переменная x теперь равна 6
    print (x) # => 6

setX(43)
setGlobalX(6)

# В Python функции — «объекты первого класса»
def create_adder(x):
    def adder(y):
        return x + y
    return adder

add_10 = create_adder(10)
add_10(3) #=> 13

# Также есть и анонимные функции
(lambda x: x > 2)(3) #=> True

# Есть встроенные функции высшего порядка
map(add_10, [1,2,3]) #=> [11, 12, 13]
filter(lambda x: x > 5, [3, 4, 5, 6, 7]) #=> [6, 7]

# Для удобного отображения и фильтрации можно использовать списочные включения
[add_10(i) for i in [1, 2, 3]]  #=> [11, 12, 13]
[x for x in [3, 4, 5, 6, 7] if x > 5] #=> [6, 7]

####################################################
## 5. Классы
####################################################

# Чтобы получить класс, мы наследуемся от object.
class Human(object):

    # Атрибут класса. Он разделяется всеми экземплярами этого класса
    species = "H. sapiens"

    # Обычный конструктор, вызывается при инициализации экземпляра класса
    # Обратите внимание, что двойное подчёркивание в начале и в конце имени
    # означает объекты и атрибуты, которые используются Python, но находятся
    # в пространствах имён, управляемых пользователем.
    # Не придумывайте им имена самостоятельно.
    def __init__(self, name):
        # Присваивание значения аргумента атрибуту класса name
        self.name = name

    # Метод экземпляра. Все методы принимают self в качестве первого аргумента
    def say(self, msg):
        return "{name}: {message}".format(name=self.name, message=msg)

    # Метод класса разделяется между всеми экземплярами
    # Они вызываются с указыванием вызывающего класса в качестве первого аргумента
    @classmethod
    def get_species(cls):
        return cls.species

    # Статический метод вызывается без ссылки на класс или экземпляр
    @staticmethod
    def grunt():
        return "*grunt*"


# Инициализация экземпляра класса
i = Human(name="Иван")
print(i.say("привет"))     # Выводит: «Иван: привет»

j = Human("Пётр")
print(j.say("Привет"))  # Выводит: «Пётр: привет»

# Вызов метода класса
i.get_species() #=> "H. sapiens"

# Изменение разделяемого атрибута
Human.species = "H. neanderthalensis"
i.get_species() #=> "H. neanderthalensis"
j.get_species() #=> "H. neanderthalensis"

# Вызов статического метода
Human.grunt() #=> "*grunt*"


####################################################
## 6. Модули
####################################################

# Вы можете импортировать модули
import math
print(math.sqrt(16)) #=> 4.0

# Вы можете импортировать отдельные функции модуля
from math import ceil, floor
print(ceil(3.7))  #=> 4.0
print(floor(3.7)) #=> 3.0

# Можете импортировать все функции модуля.
# (Хотя это и не рекомендуется)
from math import *

# Можете сокращать имена модулей
import math as m
math.sqrt(16) == m.sqrt(16) #=> True

# Модули в Python — это обычные Python-файлы. Вы
# можете писать свои модули и импортировать их. Название
# модуля совпадает с названием файла.

# Вы можете узнать, какие функции и атрибуты определены 
# в модуле
import math
dir(math)

####################################################
## 7. Дополнительно
####################################################

# Генераторы помогут выполнить ленивые вычисления
def double_numbers(iterable):
    for i in iterable:
        yield i + i

# Генератор создаёт значения на лету.
# Он не возвращает все значения разом, а создаёт каждое из них при каждой
# итерации.  Это значит, что значения больше 15 в double_numbers
# обработаны не будут.
# Обратите внимание: range — это тоже генератор.
# Создание списка чисел от 1 до 900000000 требует много места и времени.
# Если нам нужно имя переменной, совпадающее с ключевым словом Python,
# мы используем подчёркивание в конце
range_ = range(1, 900000000)

# Будет удваивать все числа, пока результат не превысит 30
for i in double_numbers(range_):
    print(i)
    if i >= 30:
        break


# Декораторы
# В этом примере beg оборачивает say
# Метод beg вызовет say. Если say_please равно True,
# он изменит возвращаемое сообщение
from functools import wraps


def beg(target_function):
    @wraps(target_function)
    def wrapper(*args, **kwargs):
        msg, say_please = target_function(*args, **kwargs)
        if say_please:
            return "{} {}".format(msg, " Пожалуйста! У меня нет денег :(")
        return msg

    return wrapper


@beg
def say(say_please=False):
    msg = "Вы не купите мне пива?"
    return msg, say_please


print(say())  # Вы не купите мне пива?
print(say(say_please=True)) # Вы не купите мне пива? Пожалуйста! У меня нет денег :(

```

## Хотите ещё?

### Бесплатные онлайн-материалы

* [Learn Python The Hard Way](http://learnpythonthehardway.org/book/)
* [Dive Into Python](http://www.diveintopython.net/)
* [Ideas for Python Projects](http://pythonpracticeprojects.com)
* [Официальная документация](http://docs.python.org/3/)
* [Hitchhiker's Guide to Python](http://docs.python-guide.org/en/latest/)
* [Python Module of the Week](http://pymotw.com/3/)
* [A Crash Course in Python for Scientists](http://nbviewer.ipython.org/5920182)

### Платные

* [Programming Python](http://www.amazon.com/gp/product/0596158106/ref=as_li_qf_sp_asin_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=0596158106&linkCode=as2&tag=homebits04-20)
* [Dive Into Python](http://www.amazon.com/gp/product/1441413022/ref=as_li_tf_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1441413022&linkCode=as2&tag=homebits04-20)
* [Python Essential Reference](http://www.amazon.com/gp/product/0672329786/ref=as_li_tf_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=0672329786&linkCode=as2&tag=homebits04-20)

