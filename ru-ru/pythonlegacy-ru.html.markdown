---
language: Python 2 (legacy)
lang: ru-ru
contributors:
    - ["Louie Dinh", "http://ldinh.ca"]
translators:
    - ["Yury Timofeev", "http://twitter.com/gagar1n"]
    - ["Andre Polykanine", "https://github.com/Oire"]
filename: learnpythonlegacy-ru.py
---

Язык Python был создан Гвидо ван Россумом в начале 90-х. Сейчас это один из
самых популярных языков. Я влюбился в Python за понятный и доходчивый синтаксис  — это
почти исполняемый псевдокод.

С благодарностью жду ваших отзывов: [@louiedinh](http://twitter.com/louiedinh)
или louiedinh [at] [почтовый сервис Google]

Замечание: Эта статья относится к Python 2.7, но должно работать и в других версиях Python 2.x.
Чтобы изучить Python 3.x, обратитесь к статье по Python 3.

```python
# Однострочные комментарии начинаются с символа решётки.
""" Многострочный текст может быть 
    записан, используя 3 знака " и обычно используется
    в качестве встроенной документации
"""

####################################################
## 1. Примитивные типы данных и операторы
####################################################

# У вас есть числа
3 #=> 3

# Математика работает вполне ожидаемо
1 + 1 #=> 2
8 - 1 #=> 7
10 * 2 #=> 20
35 / 5 #=> 7

# А вот деление немного сложнее. В этом случае происходит деление 
# целых чисел, и результат автоматически округляется в меньшую сторону.
5 / 2 #=> 2

# Чтобы делить правильно, сначала нужно немного узнать о числах
# с плавающей запятой.
2.0     # Это число с плавающей запятой
11.0 / 4.0 #=> 2.75 Вооот... Так гораздо лучше

# Результат целочисленного деления округляется в меньшую сторону
# как для положительных, так и для отрицательных чисел.
5 // 3     # => 1
5.0 // 3.0 # => 1.0 # работает и для чисел с плавающей запятой
-5 // 3  # => -2
-5.0 // 3.0 # => -2.0

# Остаток от деления
7 % 3 # => 1

# Возведение в степень
2**4 # => 16

# Приоритет операций указывается скобками
(1 + 3) * 2 #=> 8

# Логические операторы
# Обратите внимание: ключевые слова «and» и «or» чувствительны к регистру букв
True and False #=> False
False or True #=> True

# Обратите внимание, что логические операторы используются и с целыми числами
0 and 2 #=> 0
-5 or 0 #=> -5
0 == False #=> True
2 == True #=> False
1 == True #=> True

# Для отрицания используется ключевое слово not
not True #=> False
not False #=> True

# Равенство — это ==
1 == 1 #=> True
2 == 1 #=> False

# Неравенство — это !=
1 != 1 #=> False
2 != 1 #=> True

# Ещё немного сравнений
1 < 10 #=> True
1 > 10 #=> False
2 <= 2 #=> True
2 >= 2 #=> True

# Сравнения могут быть записаны цепочкой!
1 < 2 < 3 #=> True
2 < 3 < 2 #=> False

# Строки определяются символом " или '
"Это строка."
'Это тоже строка.'

# И строки тоже можно складывать!
"Привет " + "мир!" #=> "Привет мир!"

# ... или умножать
"Привет" * 3  # => "ПриветПриветПривет"

# Со строкой можно работать, как со списком символов
"Это строка"[0] #=> 'Э'

# Символ % используется для форматирования строк, например:
"%s могут быть %s" % ("строки", "интерполированы")

# Новый способ форматирования строк — использование метода format.
# Это предпочитаемый способ.
"{0} могут быть {1}".format("строки", "форматированы")

# Если вы не хотите считать, можете использовать ключевые слова.
"{name} хочет есть {food}".format(name="Боб", food="лазанью")

# None является объектом
None #=> None

# Не используйте оператор равенства '=='' для сравнения 
# объектов с None. Используйте для этого «is»
"etc" is None #=> False
None is None  #=> True

# Оператор 'is' проверяет идентичность объектов. Он не 
# очень полезен при работе с примитивными типами, но 
# зато просто незаменим при работе с объектами.

# None, 0 и пустые строки/списки равны False.
# Все остальные значения равны True
0 == False  #=> True
"" == False #=> True


####################################################
## 2. Переменные и коллекции
####################################################

# В Python есть оператор print, доступный в версиях 2.x, но удалённый в версии 3
print "Я Python. Приятно познакомиться!"
# В Python также есть функция print(), доступная в версиях 2.7 и 3,
# Но для версии 2.7 нужно добавить следующий импорт модуля (раскомментируйте)):
# from __future__ import print_function
print("Я тоже Python! ")

# Объявлять переменные перед инициализацией не нужно.
some_var = 5    # По соглашению используется нижний_регистр_с_подчёркиваниями
some_var #=> 5

# При попытке доступа к неинициализированной переменной
# выбрасывается исключение.
# См. раздел «Поток управления» для информации об исключениях.
some_other_var  # Выбрасывает ошибку именования

# if может быть использован как выражение
"yahoo!" if 3 > 2 else 2 #=> "yahoo!"

# Списки хранят последовательности
li = []
# Можно сразу начать с заполненного списка
other_li = [4, 5, 6]

# строка разделена в список
a="adambard"
list(a) #=> ['a','d','a','m','b','a','r','d']

# Объекты добавляются в конец списка методом append
li.append(1)    # [1]
li.append(2)    # [1, 2]
li.append(4)    # [1, 2, 4]
li.append(3)    # [1, 2, 4, 3]
# И удаляются с конца методом pop
li.pop()        #=> возвращает 3 и li становится равен [1, 2, 4]
# Положим элемент обратно
li.append(3)    # [1, 2, 4, 3].

# Обращайтесь со списком, как с обычным массивом
li[0] #=> 1
# Присваивайте новые значения уже инициализированным индексам с помощью =
li[0] = 42
li[0]  # => 42
li[0] = 1  # Обратите внимание: возвращаемся на исходное значение
# Обратимся к последнему элементу
li[-1] #=> 3

# Попытка выйти за границы массива приведёт к ошибке индекса
li[4] # Выдаёт IndexError

# Можно обращаться к диапазону, используя так называемые срезы
# (Для тех, кто любит математику, это называется замкнуто-открытый интервал).
li[1:3] #=> [2, 4]
# Опускаем начало
li[2:] #=> [4, 3]
# Опускаем конец
li[:3] #=> [1, 2, 4]
# Выбираем каждый второй элемент
li[::2]   # =>[1, 4]
# Переворачиваем список
li[::-1]   # => [3, 4, 2, 1]
# Используйте сочетания всего вышеназванного для выделения более сложных срезов
# li[начало:конец:шаг]

# Удаляем произвольные элементы из списка оператором del
del li[2] # li теперь [1, 2, 3]

# Вы можете складывать, или, как ещё говорят, конкатенировать списки
li + other_li #=> [1, 2, 3, 4, 5, 6]  — Замечание: li и other_li не изменяются
# Обратите внимание: значения li и other_li при этом не изменились.

# Объединять списки можно методом extend
li.extend(other_li) # Теперь li содержит [1, 2, 3, 4, 5, 6]

# Проверить элемент на вхождение в список можно оператором in
1 in li #=> True

# Длина списка вычисляется функцией len
len(li) #=> 6


# Кортежи — это такие списки, только неизменяемые
tup = (1, 2, 3)
tup[0] #=> 1
tup[0] = 3  # Выдаёт TypeError

# Всё то же самое можно делать и с кортежами
len(tup) #=> 3
tup + (4, 5, 6) #=> (1, 2, 3, 4, 5, 6)
tup[:2] #=> (1, 2)
2 in tup #=> True

# Вы можете распаковывать кортежи (или списки) в переменные
a, b, c = (1, 2, 3)     # a == 1, b == 2 и c == 3
# Кортежи создаются по умолчанию, если опущены скобки
d, e, f = 4, 5, 6
# Обратите внимание, как легко поменять местами значения двух переменных
e, d = d, e     # теперь d == 5, а e == 4

#  Словари содержат ассоциативные массивы
empty_dict = {}
# Вот так описывается предзаполненный словарь
filled_dict = {"one": 1, "two": 2, "three": 3}

# Значения извлекаются так же, как из списка, с той лишь разницей,
# что индекс — у словарей он называется ключом — не обязан быть числом
filled_dict["one"] #=> 1

# Можно получить все ключи в виде списка с помощью метода keys
filled_dict.keys() #=> ["three", "two", "one"]
# Замечание: сохранение порядка ключей в словаре не гарантируется
# Ваши результаты могут не совпадать с этими.

# Можно получить и все значения в виде списка, используйте метод values
filled_dict.values() #=> [3, 2, 1]
# То же самое замечание насчёт порядка ключей справедливо и здесь

# При помощи оператора in можно проверять ключи на вхождение в словарь
"one" in filled_dict #=> True
1 in filled_dict #=> False

# Попытка получить значение по несуществующему ключу выбросит ошибку ключа
filled_dict["four"] # KeyError

# Чтобы избежать этого, используйте метод get()
filled_dict.get("one") #=> 1
filled_dict.get("four") #=> None
# Метод get также принимает аргумент по умолчанию, значение которого будет
# возвращено при отсутствии указанного ключа
filled_dict.get("one", 4) #=> 1
filled_dict.get("four", 4) #=> 4
# Обратите внимание, что filled_dict.get("four") всё ещё => None
# (get не устанавливает значение элемента словаря)

# Присваивайте значение ключам так же, как и в списках
filled_dict["four"] = 4  # теперь filled_dict["four"] => 4

# Метод setdefault() вставляет пару ключ-значение, только если такого ключа нет
filled_dict.setdefault("five", 5) #filled_dict["five"] возвращает 5
filled_dict.setdefault("five", 6) #filled_dict["five"] по-прежнему возвращает 5


# Множества содержат... ну, в общем, множества
# (которые похожи на списки, только в них не может быть дублирующихся элементов)
empty_set = set()
# Инициализация множества набором значений
some_set = set([1,2,2,3,4]) # some_set теперь равно set([1, 2, 3, 4])

# Порядок сортировки не гарантируется, хотя иногда они выглядят отсортированными
another_set = set([4, 3, 2, 2, 1])  # another_set теперь set([1, 2, 3, 4])

# Начиная с Python 2.7, вы можете использовать {}, чтобы объявить множество
filled_set = {1, 2, 2, 3, 4} # => {1, 2, 3, 4}

# Добавление новых элементов в множество
filled_set.add(5) # filled_set равно {1, 2, 3, 4, 5}

# Пересечение множеств: &
other_set = {3, 4, 5, 6}
filled_set & other_set #=> {3, 4, 5}

# Объединение множеств: |
filled_set | other_set #=> {1, 2, 3, 4, 5, 6}

# Разность множеств: -
{1,2,3,4} - {2,3,5} #=> {1, 4}

# Проверка на вхождение во множество: in
2 in filled_set #=> True
10 in filled_set #=> False


####################################################
## 3. Поток управления
####################################################

# Для начала заведём переменную
some_var = 5

# Так выглядит выражение if. Отступы в python очень важны!
# результат: «some_var меньше, чем 10»
if some_var > 10:
    print("some_var намного больше, чем 10.")
elif some_var < 10:    # Выражение elif необязательно.
    print("some_var меньше, чем 10.")
else:           # Это тоже необязательно.
    print("some_var равно 10.")


"""
Циклы For проходят по спискам

Результат:
    собака — это млекопитающее
    кошка — это млекопитающее
    мышь — это млекопитающее
"""
for animal in ["собака", "кошка", "мышь"]:
    # Можете использовать оператор % для интерполяции форматированных строк
    print("%s — это млекопитающее" % animal)
    
"""
«range(число)» возвращает список чисел
от нуля до заданного числа
Результат:
    0
    1
    2
    3
"""
for i in range(4):
    print(i)

"""
Циклы while продолжаются до тех пор, пока указанное условие не станет ложным.
Результат:
    0
    1
    2
    3
"""
x = 0
while x < 4:
    print(x)
    x += 1  # Краткая запись для x = x + 1

# Обрабатывайте исключения блоками try/except

# Работает в Python 2.6 и выше:
try:
    # Чтобы выбросить ошибку, используется raise
    raise IndexError("Это ошибка индекса")
except IndexError as e:
    # pass — это просто отсутствие оператора. Обычно здесь происходит
    # восстановление после ошибки.
    pass
except (TypeError, NameError):
    pass    # Несколько исключений можно обработать вместе, если нужно.
else:   # Необязательное выражение. Должно следовать за последним блоком except
    print("Всё хорошо!")   # Выполнится, только если не было никаких исключений



####################################################
## 4. Функции
####################################################

# Используйте def для создания новых функций
def add(x, y):
    print("x равен %s, а y равен %s" % (x, y))
    return x + y    # Возвращайте результат с помощью ключевого слова return

# Вызов функции с аргументами
add(5, 6) #=> выводит «x равен 5, а y равен 6» и возвращает 11

# Другой способ вызова функции — вызов с именованными аргументами
add(y=6, x=5)   # Именованные аргументы можно указывать в любом порядке.

# Вы можете определить функцию, принимающую переменное число аргументов,
# которые будут интерпретированы как кортеж, если вы не используете *
def varargs(*args):
    return args

varargs(1, 2, 3) #=> (1,2,3)


# А также можете определить функцию, принимающую переменное число
# именованных аргументов, которые будут интерпретированы как словарь,
# если вы не используете **
def keyword_args(**kwargs):
    return kwargs

# Вызовем эту функцию и посмотрим, что из этого получится
keyword_args(big="foot", loch="ness") #=> {"big": "foot", "loch": "ness"}

# Если хотите, можете использовать оба способа одновременно
def all_the_args(*args, **kwargs):
    print(args)
    print(kwargs)
"""
all_the_args(1, 2, a=3, b=4) выводит:
    (1, 2)
    {"a": 3, "b": 4}
"""

# Вызывая функции, можете сделать наоборот!
# Используйте символ * для распаковки кортежей и ** для распаковки словарей
args = (1, 2, 3, 4)
kwargs = {"a": 3, "b": 4}
all_the_args(*args) # эквивалентно foo(1, 2, 3, 4)
all_the_args(**kwargs) # эквивалентно foo(a=3, b=4)
all_the_args(*args, **kwargs) # эквивалентно foo(1, 2, 3, 4, a=3, b=4)

# вы можете передавать переменное число позиционных или именованных аргументов
# другим функциям, которые их принимают, распаковывая их с помощью
# * или ** соответственно
def pass_all_the_args(*args, **kwargs):
    all_the_args(*args, **kwargs)
    print varargs(*args)
    print keyword_args(**kwargs)

# Область определения функций
x = 5

def setX(num):
    # Локальная переменная x — это не то же самое, что глобальная переменная x
    x = num # => 43
    print (x) # => 43
    
def setGlobalX(num):
    global x
    print (x) # => 5
    x = num # Глобальная переменная x теперь равна 6
    print (x) # => 6

setX(43)
setGlobalX(6)

# В Python функции — «объекты первого класса»
def create_adder(x):
    def adder(y):
        return x + y
    return adder

add_10 = create_adder(10)
add_10(3) #=> 13

# Также есть и анонимные функции
(lambda x: x > 2)(3) #=> True

# Есть встроенные функции высшего порядка
map(add_10, [1,2,3]) #=> [11, 12, 13]
filter(lambda x: x > 5, [3, 4, 5, 6, 7]) #=> [6, 7]

# Для удобного отображения и фильтрации можно использовать списочные включения
[add_10(i) for i in [1, 2, 3]]  #=> [11, 12, 13]
[x for x in [3, 4, 5, 6, 7] if x > 5] #=> [6, 7]

####################################################
## 5. Классы
####################################################

# Чтобы получить класс, мы наследуемся от object.
class Human(object):

    # Атрибут класса. Он разделяется всеми экземплярами этого класса
    species = "H. sapiens"

    # Обычный конструктор, вызывается при инициализации экземпляра класса
    # Обратите внимание, что двойное подчёркивание в начале и в конце имени
    # означает объекты и атрибуты, которые используются Python, но находятся
    # в пространствах имён, управляемых пользователем.
    # Не придумывайте им имена самостоятельно.
    def __init__(self, name):
        # Присваивание значения аргумента атрибуту класса name
        self.name = name

    # Метод экземпляра. Все методы принимают self в качестве первого аргумента
    def say(self, msg):
       return "%s: %s" % (self.name, msg)

    # Метод класса разделяется между всеми экземплярами
    # Они вызываются с указыванием вызывающего класса в качестве первого аргумента
    @classmethod
    def get_species(cls):
        return cls.species

    # Статический метод вызывается без ссылки на класс или экземпляр
    @staticmethod
    def grunt():
        return "*grunt*"


# Инициализация экземпляра класса
i = Human(name="Иван")
print(i.say("привет"))     # Выводит: «Иван: привет»

j = Human("Пётр")
print(j.say("Привет"))  # Выводит: «Пётр: привет»

# Вызов метода класса
i.get_species() #=> "H. sapiens"

# Изменение разделяемого атрибута
Human.species = "H. neanderthalensis"
i.get_species() #=> "H. neanderthalensis"
j.get_species() #=> "H. neanderthalensis"

# Вызов статического метода
Human.grunt() #=> "*grunt*"


####################################################
## 6. Модули
####################################################

# Вы можете импортировать модули
import math
print(math.sqrt(16)) #=> 4.0

# Вы можете импортировать отдельные функции модуля
from math import ceil, floor
print(ceil(3.7))  #=> 4.0
print(floor(3.7)) #=> 3.0

# Можете импортировать все функции модуля.
# (Хотя это и не рекомендуется)
from math import *

# Можете сокращать имена модулей
import math as m
math.sqrt(16) == m.sqrt(16) #=> True
# Вы также можете убедиться, что функции эквивалентны
from math import sqrt
math.sqrt == m.sqrt == sqrt  # => True

# Модули в Python — это обычные Python-файлы. Вы
# можете писать свои модули и импортировать их. Название
# модуля совпадает с названием файла.

# Вы можете узнать, какие функции и атрибуты определены 
# в модуле
import math
dir(math)

####################################################
## 7. Дополнительно
####################################################

# Генераторы помогут выполнить ленивые вычисления
def double_numbers(iterable):
    for i in iterable:
        yield i + i

# Генератор создаёт значения на лету.
# Он не возвращает все значения разом, а создаёт каждое из них при каждой
# итерации.  Это значит, что значения больше 15 в double_numbers
# обработаны не будут.
# Обратите внимание: xrange — это генератор, который делает то же, что и range.
# Создание списка чисел от 1 до 900000000 требует много места и времени.
# xrange создаёт объект генератора, а не список сразу, как это делает range.
# Если нам нужно имя переменной, совпадающее с ключевым словом Python,
# мы используем подчёркивание в конце
xrange_ = xrange(1, 900000000)

# Будет удваивать все числа, пока результат не превысит 30
for i in double_numbers(xrange_):
    print(i)
    if i >= 30:
        break


# Декораторы
# В этом примере beg оборачивает say
# Метод beg вызовет say. Если say_please равно True,
# он изменит возвращаемое сообщение
from functools import wraps


def beg(target_function):
    @wraps(target_function)
    def wrapper(*args, **kwargs):
        msg, say_please = target_function(*args, **kwargs)
        if say_please:
            return "{} {}".format(msg, " Пожалуйста! У меня нет денег :(")
        return msg

    return wrapper


@beg
def say(say_please=False):
    msg = "Вы не купите мне пива?"
    return msg, say_please


print(say())  # Вы не купите мне пива?
print(say(say_please=True)) # Вы не купите мне пива? Пожалуйста! У меня нет денег :(

```

## Хотите ещё?

### Бесплатные онлайн-материалы

* [Learn Python The Hard Way](http://learnpythonthehardway.org/book/)
* [Dive Into Python](http://www.diveintopython.net/)
* [Официальная документация](http://docs.python.org/2.6/)
* [Hitchhiker's Guide to Python](http://docs.python-guide.org/en/latest/)
* [Python Module of the Week](http://pymotw.com/2/)
* [A Crash Course in Python for Scientists](http://nbviewer.ipython.org/5920182)

### Платные

* [Programming Python](http://www.amazon.com/gp/product/0596158106/ref=as_li_qf_sp_asin_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=0596158106&linkCode=as2&tag=homebits04-20)
* [Dive Into Python](http://www.amazon.com/gp/product/1441413022/ref=as_li_tf_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1441413022&linkCode=as2&tag=homebits04-20)
* [Python Essential Reference](http://www.amazon.com/gp/product/0672329786/ref=as_li_tf_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=0672329786&linkCode=as2&tag=homebits04-20)

