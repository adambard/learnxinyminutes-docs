---
language: Go
filename: learngo-ru.go
contributors:
    - ["Sonia Keys", "https://github.com/soniakeys"]
    - ["Christopher Bess", "https://github.com/cbess"]
    - ["Jesse Johnson", "https://github.com/holocronweaver"]
    - ["Quint Guvernator", "https://github.com/qguv"]
translators:
    - ["Artem Medeusheyev", "https://github.com/armed"]
    - ["Valery Cherepanov", "https://github.com/qumeric"]
lang: ru-ru
---

Go - это язык общего назначения, целью которого является удобство, простота,
конкурентность. Это не тренд в компьютерных науках, а новейший и быстрый
способ решать насущные проблемы.

Концепции Go схожи с другими императивными статически типизированными языками.
Быстро компилируется и быстро исполняется, имеет лёгкие в понимании конструкции
для создания масштабируемых и многопоточных программ.

Может похвастаться отличной стандартной библиотекой и большим комьюнити, полным
энтузиастов.

```go
// Однострочный комментарий.
/* Много-
строчный комментарий */

// Название файла с которого начинается каждый бинарный файл.
// Это основное имя - main, объявленное в библиотеке.
package main

// Импортирование объявленных библиотек в этом файле.
import (
    "fmt"       // Пакет fmt из стандартной библиотеки для вывода данных в виде строк в консоль.
    "io/ioutil" // io - низкоуровневые функции ввода/вывода (imput/output),
    // ioutil - дополнительные вспомогательные высокоуровневые функции.
    m "math"   // Стандартная библиотека math для локальной переменной m.
    "net/http" // net - функции  и типы для организации обмена данными через сетевые сокеты по TCP/IP и UDP.
    // net/http - обеспечивает возможность парсига HTTP-запросов и ответов, а также реализует HTTP-клиент.
    "strconv" // String conversions - преобразование строк в значения других типов
    // и значений других типов в строки.
)

// "Main" - специальное наименование. Функция является "точкой" входа в программу,
// выполняется в первую очередь.
func main() {
    // Println выводит строку в stdout.
    // Подфункция, включенная в пакет fmt.
    fmt.Println("Добрый день/ночь")

    // Вызов другой функции в этом пакете.
    beyondHello()
}

// Параметры функций указываются в скобках ().
// Даже если параметры не указываются, синтаксически скобки необходимы -> beyondHello().
func beyondHello() { // Функция приветствия.
    var x int // Объявление переменной. Переменные должны быть объявлены перед использованием.
    x = 3     // Присваивание значение переменной.
    // Синтаксически ":=" - это определение типа, объявление и присваивание переменной одноврменно.
    y := 4
    sum, prod := learnMultiple(x, y)         // Функция "learnMultiple" возвращает 2 значения - x и y.
    fmt.Println("Сумм:", sum, "Прод:", prod) // Простой вывод.
    learnTypes()                             // 10 минут мало! Изучайте больше))
}

/* <- многострочный комментарий
Здесь `x`, `y` это параметры, затребованные функцией,
и `sum`, `prod` это значения (которые будут выведены).
Обязательно значения `x` и `sum` должны быть типа `int`.
*/
func learnMultiple(x, y int) (sum, prod int) {
    return x + y, x * y // Возвращаются 2 значения.
}

// Некоторые встроенные типы и литералы.
func learnTypes() { // Функция изучения типов в Go.
    // Короткие декларации удобны и, чаще всего, предоставляют все, что нужно.
    str := "Изучай ЯПВУ Go!" // Тип string - строка.

    s2 := `"raw" литерал string 
может включать разрывы` // Тоже string, причем `я` позволяет переносить строки.

    // Не используется кодировка ASCII. В Go код и литералы объявляются в кодировке UTF-8.
    g := 'Σ' //  Тип - rune, синоним типа int32 при работе с отдельными смволамим,
    // кодовыми пунктами Юникода.

    f := 3.14195 // Тип float64, по формату IEEE-754 64-битное вещественное число,
    // (мантисса с точностью до 15 знаков).
    c := 3 + 4i // Тип complex128, обе части, действительная и мнимая, представлены значениями float64.
.
    // Синтаксис ключевого слова - var, объявления переменной.
    var u uint = 7 // Неподписанная, но использование зависит от размера, как с типом "int".
    var pi float32 = 22. / 7/

    // Синтаксис преобразования короткой записью.
    n := byte('\n') // byte - это псевдоним uint8.

    // Массивы могут иметь фиксированный размер при компиляции.
    var a4 [4]int           // Этот массив состоит из 4 типа ints, все инициализируются 0.
    a3 := [...]int{3, 1, 5} // Этот массив инициализируется фиксированным размером из трех
    // элементов, имеющих значения 3, 1 и 5.

    // Срезы (slices) имеют динамический размер. Массивы и срезы имеют свои преимущества,
    // но использование срезов больше распространено.
    s3 := []int{4, 5, 9}    // Сравните с объявлением a3 - отсутствует многоточие.
    s4 := make([]int, 4)    // Объявляется срез из 4 элементов типа ints, все инициализированы 0.
    var d2 [][]float64      // Только объявление, без инициализации элементов.
    bs := []byte("a slice") // Синтаксис преобразования типа.

    // В связи с тем, что срезы динамические, элементы могут быть добавлены.
    // Для добавления элемента в срез, используется встроенная команда append().
    // Первый аргумент - это срез к которому мы будем добавлять элементы.
    // Массив переменного объема обновляется, как в примере внизу.
    s := []int{1, 2, 3}    // Срез объемом 3 элемента типа int.
    s = append(s, 4, 5, 6) // Добавим 3 элемента. Срез теперь становится объемом 6 элементов.
    fmt.Println(s)         // Обновленный срез теперь - [1 2 3 4 5 6].

    // Для того, чтобы добавить еще срез, а не просто отдельные элементы,
    // можно передать ссылку на срез или сам срез, обязательно
    // указывая многоточие. Таким образом, указывая взять срез и распаковать его элементы,
    // добавив их в срез s.
    s = append(s, []int{7, 8, 9}...) // Второй аргумент это литерал среза.
    fmt.Println(s)                   // Теперь срез - [1 2 3 4 5 6 7 8 9].

    p, q := learnMemory() // Объявление p, q - типа указатель на int.
    fmt.Println(*p, *q)   // За знаком * следут указатель. Вывод двух переменных типа int.

    // Тип данных - Maps (отображения), является динамическим расширяемым ассоциативным массивом, или
    // по другому, неупорядоченной колекцией пар ключ/значение.
    m := map[string]int{"three": 3, "four": 4}
    m["one"] = 1

    // Пустой идентификатор в Go.
    // Подчеркивания позволяют использовать переменную, но отбросить ее приваиваемое значение.
    _, _, _, _, _, _, _, _, _, _ = str, s2, g, f, u, pi, n, a3, s4, bs
    // Вывод отчетов с помощью переменных.
    fmt.Println(s, c, a4, s3, d2, m)

    learnFlowControl() // Вывод в поток.
}

// Функции в Go.
// Синтаксис:
// Вариант1: func имяФункции(необязательныеПараметры) типНеобязательногоВозвращаемогоЗначения {
//      тело
//  }
// Вариант2: func имяФункции(необязательныеПараметры) (необязательныеВозвращаемыеЗначения) {
//      тело
//  }
// Присвоение имени к типу возвращаемого значения возвращается при объявлениии функции -
// это позволяет легко вернуть значения из любой точки функции
// или использовать ключевое слово возвращения значения - return.
func learnNamedReturns(x, y int) (z int) { // Функция изучения возвращения значений функций.
    z = x * y
    return // z возвращается сейчас, объявлена была заранее.
}

// В Go реализована автоматическая сборка мусора. В функции объявлены указатели, но нет операции с ними.
// Здесь можно сделать ошибку при нулевом указателе, но не при приращении указателя.
func learnMemory() (p, q *int) { // Функция изучения работы с памятью.
    // Объявленные возвращаемые значения p и q имеют ссылку на тип int.
    p = new(int) // Встроенная функция выделяет новую область памяти.
    // Область int инициализирована 0, переменная p не равна nil.
    s := make([]int, 20) // Размещается 20 значений типа ints в одном блоке памяти.
    s[3] = 7             // Один из них замещается.
    r := -2              // Объявляется ее одна локальная переменная.
    return &s[3], &r     // & принимает адрес объекта.
}

func expensiveComputation() float64 {
    return m.Exp(10)
}

func learnFlowControl() { // функция изучения управления потоком.
    // Встроенная If требует использования фигурных скобок, и не требует круглых.
    if true {
        fmt.Println("Эххххх! Эге-гей!")
    }
    // Форматирование стандартизовано в "go fmt".
    if false {
        // Смеемся.
    } else {
        // Плачем.
    }

    /* Синтаксис инструкции if:
    if необязательнаяИнструкция1; логическоеВыражение1 {
        блок1
    } else if необязательнаяИнструкция2; логическоеВыражение2 {
        блок2
    } else {
        блок3
    }
    */

    // Использование переключателя switch, если необходим выбор (по значению, типу).
    x := 42.0
    switch x {
    case 0:
    case 1:
    case 42:
        // Случаи выбора не пропускаются.
        /*
            Имеется ключевое слово `fallthrough` для пропуска выбора, дополнительно:
              https://github.com/golang/go/wiki/Switch#fall-through.
        */
    case 43:
        // Неиспользуемое.
    default:
        // Случай выбора по умолчанию, не является обязательным.
    }

    /* Синтаксис инструкции switch:
    -- выбор по значению:
    switch необязательнаяИнструкция; необязательноеВыражение {
        case списокВыражений1: блок1
        ...
        case списокВыраженийN: блокN
        default: блокD
    }

    -- выбор по типу:
    switch необязательнаяИнструкция; переключательТипа {
        case списокТипов1: блок1
        ...
        case списокТиповN: блокN
        default: блокD
    }
    */

    // В Go имеются 2 вида инструкции for: for и for ... range.
    // Так же как инструкция if, инструкция for скобки {} являются обязательными.
    // Переменные объявленные в for и if являются локальными для своей области видимости.
    // Логичское выражение должно возвращать тип bool.
    for x := 0; x < 3; x++ { // ++ это заявление (в каждом проходе увеличение на 1).
        fmt.Println("операция", x)
    }
    // Здесь значение x == 42 - это другая область видимости.

    // Инструкция For является оператором цикла в Go, но имеет альтернативные формы.
    for { // Бесконечный цикл.
        break // Шутка - останов.
        continue
    }

    // Можно использовать оператор range для итераций по массивам (array), срезам (slice),
    // строкам (string), отображениям (map), или каналов (channel).
    // range возвращает одно значение (для channel) или два (для array, slice, string и map).
    for key, value := range map[string]int{"one": 1, "two": 2, "three": 3} {
        // Для каждой пары ключ/значение в отображении, напечатать ключ и значение.
        fmt.Printf("ключ=%s, значение=%d\n", key, value)
    }

    /* Синтаксис инструкции for:
    ----------------------------
    for { // бесконечный цикл
        блок
    }
    ----------------------------
    for логическоеВыражение { // цикл while
        блок
    }
    ----------------------------
    for необязательнаяПредИнструкция; логическоеВыражение; необязательнаяПостИнструкция {
        // пред- и пост- инстркции должны быть простыми выражениями
        блок
    }
    ----------------------------
    for индекс, символ := range Строка { // итерации по символам в Строке
        блок
    }
    ----------------------------
    for индекс := range Строка{ // итерации по символам в Строке - возвращает индексы байтов
        блок // символ, размер := utf8.DecodeRuneString(Строка[индекс:])
    }
    ----------------------------
    for индекс, элемент := range массивИлиСрез { // итерации по массиву или срезу
        блок
    }
    ----------------------------
    for index := range массивИлиСрез { // итерации по массиву или срезу - для не пустых срезов или массивов
    // возвращает индексы элементов от 0 до len(срез)-1
        блок // item := массивИлиСрез[index]
    }
    ----------------------------
    for ключ, значение := range Отображение { // итерации по элементам отображения
        блок
    }
    ----------------------------
    for ключ := range Отображение { // бесконечный цикл
        блок // значение := Отображение[ключ]
    }
    ----------------------------
    for элемент := range Канал { // итерации по элементам в канале
        блок
    }
    */

    // Также как в инструкции for, := используется в инструкции if и означает присвоение, объявление.
    // Сначала с y проводятся операции по инструкции, затем логическая проверка y > x.
    if y := expensiveComputation(); y > x {
        x = y
    }

    /* Синтаксис инструкции if:
    if необязательнаяИнструкция1; логическоеВыражение1 {
        блок1
    } else if необязательнаяИнструкция2; логическоеВыражение2 {
    // может иметь 0 или более конструкций else if
        блок2
    } else { // может иметь 0 или более конструкций else
        блок3
    }
    */

    // Литералы функций могут использоваться как замыкания:
    xBig := func() bool {
        return x > 10000 // x объявлена выше, перед описанием инструкции switch.
    }
    fmt.Println("xBig:", xBig()) // Здесь логическое выражение = true (ранее х присвоено значение e^10).
    x = 1.3e3                    // Присваиваем значение x == 1300.
    fmt.Println("xBig:", xBig()) // Теперь false.
    /*
        Замыкание (от англ. closure) в программировании — функция первого класса,
        в теле которой присутствуют ссылки на переменные, объявленные вне тела
        этой функции в окружающем коде и не являющиеся её параметрами.
        Говоря другим языком, замыкание — функция,
        которая ссылается на свободные переменные в своём контексте.
    */

    // Литералы функций могут быть определены и вызваны в теле,
    // могут действовать в качестве одного из аргументов функций, при условии:
    // a) литералы функций вызываются немендленно (),
    // b) результат соответсвует типу ожидаемого аргумента.
    fmt.Println("Добавление + умножение на 2 двух чисел: ",
        func(a, b int) int {
            return (a + b) * 2
        }(10, 2)) // Вызов аргументов 10 и 2.
    // => Добавление + умнодение на 2 двух чисел: 24.

    // Когда это будет нужно, ты будешь любить это.
    goto love
love:

    learnFunctionFactory() // Функция возвращает функцию fun(3)(3).
    learnDefer()      // Быстрый кружной путь к важному ключевому слову.
    learnInterfaces() // Надо хорошенько подумать!
}

func learnFunctionFactory() { // Функция изучения вызова функций в функциях.
    // Следующие операции эквивалентны, но вторая более практична.
    fmt.Println(sentenceFactory("летний")("Хороший", "день!  -1"))

    d := sentenceFactory("летний")
    fmt.Println(d("Хороший", "день!  -2"))
    fmt.Println(d("Ленивый", "вечер! -2"))
}

// Декораторы распространены в других языках. Это же можно реализовать в Go
// с литералами функций, которые принимают аргументы.
func sentenceFactory(mystring string) func(before, after string) string {
    return func(before, after string) string {
        return fmt.Sprintf("%s %s %s", before, mystring, after) // новая строка.
    }
}

func learnDefer() (ok bool) { // Функция изучения исполнения отложенных инструкций.
    // Отложенные инструкции выполняются непосредственно перед возвратом значения функции.
    defer fmt.Println("отложенные действия выполняются в обратном порядке: LIFO метод.")
    // По методу FIFO первым выдаётся самый старый из пришедших товаров, по методу LIFO — самый новый.
    defer fmt.Println("\nЭта строчка напечатана первой, потому что")
    // Defer обычно используется, если требуется закрыть файл перед закрытием функции
    // файл обязательно будет закрыт перед закрытием функции.
    return true
}

// Определяем Stringer как интерфейс с одним методом - String.
type Stringer interface {
    String() string
}

// Определяем pair как структуру (struct) с двумя элементами типа int, названными x и y.
type pair struct {
    x, y int
}

// Определяем метод для типа pair. Для Pair теперь определен интерфейс Stringer с методом string.
func (p pair) String() string { // p называется "receiver" (приемник).
    // Sprintf публичная функция из пакета fmt.
    // Синтаксис точки (.) позводяет ссылаться на p (приемник).
    return fmt.Sprintf("(%d, %d)", p.x, p.y)
}

func learnInterfaces() { // Функция изучения интерфейсов.
    // Интерфейс - это тип, определяющий сигнатуры одного или более методов.
    // Синтаксис := декларирует и инициализирует p в этой структуре.
    p := pair{3, 4}
    fmt.Println(p.String()) // Обращение к методу String для p, типа pair.
    var i Stringer          // Объявление переменной i, относящейся к интерфейсу типа Stringer.
    i = p                   // Верно, потому что pair включает интерфейс Stringer.
    // Вызов метода String для i, типа Stringer.
    fmt.Println(i.String()) // Вывод данных, такой же как и выше -> fmt.Println(p.String()).

    // Функция в пакете fmt вызывает метод String, который обращается к объектам
    // для вывода данных.
    fmt.Println(p) // Вывод данных, такой же как и выше. Println вызывает метод String.
    fmt.Println(i) // Вывод данных, такой же как и выше.

    learnVariadicParams("хорошо", "учитесь", "тут!")
}

// Функции могут иметь параметры variadic - ...
func learnVariadicParams(myStrings ...interface{}) { // функция изучения variadic.
    // Итерация по значениям переменных с помощью variadic.
    // Подчеркивание здесь позволяет игнорировать индекс аргумента в массиве.
    for _, param := range myStrings {
        fmt.Println("параметр:", param)
    }

    // Пассивное variadic переменная в качестве variadic параметра.
    fmt.Println("параметры:", fmt.Sprintln(myStrings...))

    learnErrorHandling()
}

func learnErrorHandling() { // Функция изучения обработки ошибок.
    // ", ok" идиома используется, чтобы обозначить работу: работает или нет.
    m := map[int]string{3: "три", 4: "четыре"}
    if x, ok := m[1]; !ok { // ok будет ложным, потому что 1 не входит в отображение.
        fmt.Println("здесь нет единицы")
    } else {
        fmt.Print(x) // x было бы значением, если бы входило в отображение.
    }
    // Значение ошибки говорит не только о "ok", но больше о проблеме в программе.
    if _, err := strconv.Atoi("не тип int"); err != nil { // _ ошибочное значение.
        // Вывод на печать 'strconv.ParseInt: parsing "не тип int": invalid syntax' - ошибочный синтаксис.
        fmt.Println(err)
    }
    // Возврат в интерфейсы будет, несколько позже.
    learnConcurrency()
}

// c это канал, объект безопасного взаимодействия с распараллеленными потоками выполнения.
func inc(i int, c chan int) {
    c <- i + 1 // <- оператор "отправить" ("send"), когда канал находится слева от оператора.
}

// Будем использовать inc для увеличения числа параллельных потоков.
func learnConcurrency() { // функция изучения параллелизма.
    // Эта же функция испльзовалась ранее, чтобы получить срезы.
    // make()  - каналы, срезы и отображения, создаются с помощью этой функции,
    // всегда возвращает ссылку на создаваемое ей значение.
    c := make(chan int)
    // Запускаем три параллельных горутины (goroutines). Числа будут увеличиваться
    // параллельно, если это поддерживается ЭВМ и правильно настроено.
    // Все три значения посылаются в один канал.
    go inc(0, c) // go - это утверждение, что начинается исполнение новой горутины.
    go inc(10, c)
    go inc(-805, c)
    // Прочитаем три результата из канала и выведем этот результат.
    // Никто не знает, в каком порядке результаты будут прибывать!
    fmt.Println(<-c, <-c, <-c) // Канал справа, <- это "приемный" ("receive") оператор.

    cs := make(chan string)       // Другой канал, обрабатывает строки.
    ccs := make(chan chan string) // Канал для каналов со строками.
    go func() { c <- 84 }()       // Запуск новой горутины с посылкой простого значения.
    go func() { cs <- "wordy" }() // Снова, теперь для cs.
    // Select - синтаксис, как для переключателя switch, но каждый случай включает в себя
    // операции с каналами. Этот переключатель выводит данные из канала в случайном порядке,
    // которые в текущий момент готов выдать данные.
    select {
    case i := <-c: // Полученное значение может быть присвоено переменной.
        fmt.Printf("Эта %T", i)
    case <-cs: // или значения могут быть отброшены.
        fmt.Println("строка")
    case <-ccs: // Пустой канал, не готовый к выдаче данных.
        fmt.Println("не счастлива.")
    }
    // В этой точке значение было взято либо из c, либо из cs. Одна из двух
    // горутин выполнилась раньше, другая будет заблокирована.

    learnWebProgramming() // Go делает это. Вы тоже сможете это сделать.
}

// Функция из пакета http для старта вебсервера.
func learnWebProgramming() { // Функция изучения программированния на Go для веб.

    // 1й параметр ListenAndServe это TCP адрес, по которому сервер будет слушать запросы,
    // 2й параметр это интерфейс, специальный http.Handler.
    go func() {
        err := http.ListenAndServe(":8080", pair{})
        fmt.Println(err) // Не инорировать ошибки.
    }()

    requestServer()
}

// Создаем pair из http.Handler путем реализации своего единственного метода: ServeHTTP
func (p pair) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    // Подаем данные, используя метод http.ResponseWriter.
    w.Write([]byte("Вы изучили Go за Y минут!"))
}

func requestServer() {
    resp, err := http.Get("http://localhost:8080")
    fmt.Println(err)
    defer resp.Body.Close()
    body, err := ioutil.ReadAll(resp.Body)
    fmt.Printf("\nВебсервер говорит: `%s`", string(body))
}
```

## Что дальше

Основа всех основ в Go это [официальный веб сайт](http://golang.org/).
Там можно пройти туториал, поиграться с интерактивной средой Go и почитать
объёмную документацию.

Для живого ознакомления рекомендуется почитать исходные коды [стандартной
библиотеки Go](http://golang.org/src/pkg/). Отлично задокументированная, она
является лучшим источником для чтения и понимания Go, его стиля и идиом. Либо
можно, кликнув на имени функции в [документации](http://golang.org/pkg/),
перейти к ее исходным кодам.
