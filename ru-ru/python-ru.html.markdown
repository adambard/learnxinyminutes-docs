---
language: python
lang: ru-ru
contributors:
    - ["Louie Dinh", "http://ldinh.ca"]
translators:
    - ["Yury Timofeev", "http://twitter.com/gagar1n"]
filename: learnpython-ru.py
---

Язык Python был создан Гвидо ван Россумом в начале 90-х. Сейчас это один из самых популярных 
языков. Я люблю его за его понятный и доходчивый синтаксис - это почти что исполняемый псевдокод.

С благодарностью жду ваших отзывов: [@louiedinh](http://twitter.com/louiedinh) или louiedinh [at] [google's email service]

Замечание: Эта статья относится к Python 2.7, но должно работать и в Python 2.x. Скоро будет версия и для Python 3!

```python
# Однострочные комментарии начинаются с hash-символа.
""" Многострочный текст может быть 
    записан, используя 3 знака " и обычно используется
    в качестве комментария
"""

####################################################
## 1. Примитивные типы данных и операторов
####################################################

# У вас есть числа
3 #=> 3

# Математика работает вполне ожидаемо
1 + 1 #=> 2
8 - 1 #=> 7
10 * 2 #=> 20
35 / 5 #=> 7

# А вот деление немного сложнее. В этом случае происходит деление 
# целых чисел и результат автоматически округляется в меньшую сторону.
5 / 2 #=> 2

# Чтобы научиться делить, сначала нужно немного узнать о дробных числах.
2.0     # Это дробное число
11.0 / 4.0 #=> 2.75 Вооот... Так гораздо лучше

# Приоритет операций указывается скобками
(1 + 3) * 2 #=> 8

# Логические значения являются примитивами
True
False

# Для отрицания используется ключевое слово not
not True #=> False
not False #=> True

# Равенство это ==
1 == 1 #=> True
2 == 1 #=> False

# Неравенство это !=
1 != 1 #=> False
2 != 1 #=> True

# Еще немного сравнений
1 < 10 #=> True
1 > 10 #=> False
2 <= 2 #=> True
2 >= 2 #=> True

# Сравнения могут быть соединены в цепь!
1 < 2 < 3 #=> True
2 < 3 < 2 #=> False

# Строки определяются символом " или '
"Это строка."
'Это тоже строка.'

# И строки тоже могут складываться!
"Привет " + "мир!" #=> "Привет мир!"

# Со строкой можно работать, как со списком символов
"Это строка"[0] #=> 'Э'

# Символ % используется для форматирования строк, например:
"%s могут быть %s" % ("строки", "интерполированы")

# Новый метод форматирования строк - использование метода format.
# Это предпочитаемый способ.
"{0} могут быть {1}".format("строки", "форматированы")
# Если вы не хотите считать, можете использовать ключевые слова.
"{name} хочет есть {food}".format(name="Боб", food="лазанью")

# None является объектом
None #=> None

# Не используйте оператор равенства '=='' для сравнения 
# объектов с None. Используйте для этого 'is'
"etc" is None #=> False
None is None  #=> True

# Оператор 'is' проверяет идентичность объектов. Он не 
# очень полезен при работе с примитивными типами, но 
# зато просто незаменим при работе с объектами.

# None, 0, и пустые строки/списки равны False.
# Все остальные значения равны True
0 == False  #=> True
"" == False #=> True


####################################################
## 2. Переменные и коллекции
####################################################

# Печатать довольно просто
print "Я Python. Приятно познакомиться!"


# Необязательно объявлять переменные перед их инициализацией.
some_var = 5    # По соглашению используется нижний_регистр_с_подчеркиваниями
some_var #=> 5

# При попытке доступа к неинициализированной переменной,
# выбрасывается исключение.
# См. раздел "Поток управления" для информации об исключениях.
some_other_var  # Выбрасывает ошибку именования

# if может быть использован как выражение
"yahoo!" if 3 > 2 else 2 #=> "yahoo!"

# Списки хранят последовательности
li = []
# Можно сразу начать с заполненным списком
other_li = [4, 5, 6]

# Объекты добавляются в конец списка методом append
li.append(1)    # [1]
li.append(2)    # [1, 2]
li.append(4)    # [1, 2, 4]
li.append(3)    # [1, 2, 4, 3]
# И удаляются с конца методом pop
li.pop()        #=> возвращает 3 и li становится равен [1, 2, 4]
# Положим элемент обратно
li.append(3)    # [1, 2, 4, 3].

# Обращайтесь со списком, как с обычным массивом
li[0] #=> 1
# Обратимся к последнему элементу
li[-1] #=> 3

# Попытка выйти за границы массива приведет к IndexError
li[4] # Выдает IndexError

# Можно обращаться к диапазону, используя "кусочный синтаксис" (slice syntax)
# (Для тех, кто любит математику, это называется замкнуто/открытый интервал.)
li[1:3] #=> [2, 4]
# Опускаем начало
li[2:] #=> [4, 3]
# Опускаем конец
li[:3] #=> [1, 2, 4]

# Удаляем произвольные элементы из списка оператором del
del li[2] # [1, 2, 3]

# Вы можете складывать списки
li + other_li #=> [1, 2, 3, 4, 5, 6] - Замечание: li и other_li остаются нетронутыми

# Конкатенировать списки можно методом extend
li.extend(other_li) # Теперь li содержит [1, 2, 3, 4, 5, 6]

# Проверить элемент на вхождение в список можно оператором in
1 in li #=> True

# Длина списка вычисляется функцией len
len(li) #=> 6


# Кортежи - это такие списки, только неизменяемые
tup = (1, 2, 3)
tup[0] #=> 1
tup[0] = 3  # Выдает TypeError

# Все то же самое можно делать и с кортежами
len(tup) #=> 3
tup + (4, 5, 6) #=> (1, 2, 3, 4, 5, 6)
tup[:2] #=> (1, 2)
2 in tup #=> True

# Вы можете распаковывать кортежи (или списки) в переменные
a, b, c = (1, 2, 3)     # a == 1, b == 2 и c == 3
# Кортежи создаются по умолчанию, если опущены скобки
d, e, f = 4, 5, 6
# Обратите внимание, как легко поменять местами значения двух переменных
e, d = d, e     # теперь d == 5, а e == 4


#  Словари содержат ассоциативные массивы
empty_dict = {}
# Вот так описывается предзаполненный словарь
filled_dict = {"one": 1, "two": 2, "three": 3}

# Значения ищутся по ключу с помощью оператора []
filled_dict["one"] #=> 1

# Можно получить все ключи в виде списка
filled_dict.keys() #=> ["three", "two", "one"]
# Замечание - сохранение порядка ключей в словаре не гарантируется
# Ваши результаты могут не совпадать с этими.

# Можно получить и все значения в виде списка
filled_dict.values() #=> [3, 2, 1]
# То же самое замечание насчет порядка ключей справедливо и здесь

# При помощи оператора in можно проверять ключи на вхождение в словарь
"one" in filled_dict #=> True
1 in filled_dict #=> False

# Попытка получить значение по несуществующему ключу выбросит KeyError
filled_dict["four"] # KeyError

# Чтобы избежать этого, используйте метод get
filled_dict.get("one") #=> 1
filled_dict.get("four") #=> None
# Метод get также принимает аргумент default, значение которого будет
# возвращено при отсутствии указанного ключа
filled_dict.get("one", 4) #=> 1
filled_dict.get("four", 4) #=> 4

# Метод setdefault - это безопасный способ добавить новую пару ключ-значение в словарь
filled_dict.setdefault("five", 5) #filled_dict["five"] возвращает 5
filled_dict.setdefault("five", 6) #filled_dict["five"] по прежнему возвращает 5


# Множества содержат... ну, в общем, множества
empty_set = set()
# Инициализация множества набором значений
some_set = set([1,2,2,3,4]) # some_set теперь равно set([1, 2, 3, 4])

# Начиная с Python 2.7, вы можете использовать {} чтобы обьявить множество
filled_set = {1, 2, 2, 3, 4} # => {1 2 3 4}

# Добавление новых элементов в множество
filled_set.add(5) # filled_set равно {1, 2, 3, 4, 5}

# Пересечение множеств: &
other_set = {3, 4, 5, 6}
filled_set & other_set #=> {3, 4, 5}

# Объединение множеств: |
filled_set | other_set #=> {1, 2, 3, 4, 5, 6}

# Разность множеств: -
{1,2,3,4} - {2,3,5} #=> {1, 4}

# Проверка на вхождение во множество: in
2 in filled_set #=> True
10 in filled_set #=> False


####################################################
## 3. Поток управления
####################################################

# Для начала заведем переменную
some_var = 5

# Так выглядит выражение if. Отступы в python очень важны!
# результат: "some_var меньше, чем 10"
if some_var > 10:
    print "some_var намного больше, чем 10."
elif some_var < 10:    # Выражение elif необязательно.
    print "some_var меньше, чем 10."
else:           # Это тоже необязательно.
    print "some_var равно 10."


"""
Циклы For проходят по спискам

Результат:
    собака это млекопитающее
    кошка это млекопитающее
    мышь это млекопитающее
"""
for animal in ["собака", "кошка", "мышь"]:
    # Можете использовать оператор % для интерполяции форматированных строк
    print "%s это млекопитающее" % animal
    
"""
`range(number)` возвращает список чисел
от нуля до заданного числа
Результат:
    0
    1
    2
    3
"""
for i in range(4):
    print i

"""
Циклы while продолжаются до тех пор, пока указанное условие не станет ложным.
Результат:
    0
    1
    2
    3
"""
x = 0
while x < 4:
    print x
    x += 1  # То же самое, что x = x + 1

# Обрабывайте исключения блоками try/except

# Работает в Python 2.6 и выше:
try:
    # Для выбора ошибки используется raise
    raise IndexError("Это IndexError")
except IndexError as e:
    # pass это просто отсутствие оператора. Обычно здесь происходит
    # восстановление от ошибки.
    pass


####################################################
## 4. Функции
####################################################

# Используйте def для создания новых функций
def add(x, y):
    print "x равен %s, а y равен %s" % (x, y)
    return x + y    # Возвращайте результат выражением return

# Вызов функции с аргументами
add(5, 6) #=> prints out "x равен 5, а y равен 6" и возвращает 11

# Другой способ вызова функции с аргументами
add(y=6, x=5)   # Именованные аргументы можно указывать в любом порядке.

# Вы можете определить функцию, принимающую неизвестное количество аргументов
def varargs(*args):
    return args

varargs(1, 2, 3) #=> (1,2,3)


# А также можете определить функцию, принимающую изменяющееся количество 
# именованных аргументов
def keyword_args(**kwargs):
    return kwargs

# Вызовем эту функцию и посмотрим, что из этого получится
keyword_args(big="foot", loch="ness") #=> {"big": "foot", "loch": "ness"}

# Если хотите, можете использовать оба способа одновременно
def all_the_args(*args, **kwargs):
    print args
    print kwargs
"""
all_the_args(1, 2, a=3, b=4) выводит:
    (1, 2)
    {"a": 3, "b": 4}
"""

# Вызывая функции, можете сделать наоборот!
# Используйте символ * для передачи кортежей и ** для передачи словарей
args = (1, 2, 3, 4)
kwargs = {"a": 3, "b": 4}
all_the_args(*args) # эквивалент foo(1, 2, 3, 4)
all_the_args(**kwargs) # эквивалент foo(a=3, b=4)
all_the_args(*args, **kwargs) # эквивалент foo(1, 2, 3, 4, a=3, b=4)

# Python имеет функции первого класса
def create_adder(x):
    def adder(y):
        return x + y
    return adder

add_10 = create_adder(10)
add_10(3) #=> 13

# Также есть и анонимные функции
(lambda x: x > 2)(3) #=> True

# Есть встроенные функции высшего порядка
map(add_10, [1,2,3]) #=> [11, 12, 13]
filter(lambda x: x > 5, [3, 4, 5, 6, 7]) #=> [6, 7]

# Мы можем использовать списки для удобного отображения и фильтрации
[add_10(i) for i in [1, 2, 3]]  #=> [11, 12, 13]
[x for x in [3, 4, 5, 6, 7] if x > 5] #=> [6, 7]

####################################################
## 5. Классы
####################################################

# Чтобы получить класс, мы наследуемся от object.
class Human(object):

    # Атрибут класса. Он разделяется всеми экземплярами этого класса
    species = "H. sapiens"

    # Обычный конструктор
    def __init__(self, name):
        # Присваивание значения аргумента атрибуту класса name
        self.name = name

    # Метод экземпляра. Все методы принимают self в качестве первого аргумента
    def say(self, msg):
       return "%s: %s" % (self.name, msg)

    # Метод класса разделяется между всеми экземплярами
    # Они вызываются с указыванием вызывающего класса в качестве первого аргумента
    @classmethod
    def get_species(cls):
        return cls.species

    # Статический метод вызывается без ссылки на класс или экземпляр
    @staticmethod
    def grunt():
        return "*grunt*"


# Инстанцирование класса
i = Human(name="Иван")
print i.say("привет")     # "Иван: привет"

j = Human("Петр")
print j.say("Привет")  # "Петр: привет"

# Вызов метода класса
i.get_species() #=> "H. sapiens"

# Присвоение разделяемому атрибуту
Human.species = "H. neanderthalensis"
i.get_species() #=> "H. neanderthalensis"
j.get_species() #=> "H. neanderthalensis"

# Вызов статического метода
Human.grunt() #=> "*grunt*"


####################################################
## 6. Модули
####################################################

# Вы можете импортировать модули
import math
print math.sqrt(16) #=> 4

# Вы можете импортировать отдельные функции модуля
from math import ceil, floor
print ceil(3.7)  #=> 4.0
print floor(3.7) #=> 3.0

# Можете импортировать все функции модуля.
# (Хотя это и не рекомендуется)
from math import *

# Можете сокращать имена модулей
import math as m
math.sqrt(16) == m.sqrt(16) #=> True

# Модули в Python это обычные файлы с кодом python. Вы
# можете писать свои модули и импортировать их. Название
# модуля совпадает с названием файла.

# Вы можете узнать, какие функции и атрибуты определены 
# в модуле
import math
dir(math)


```

## Хотите еще?

### Бесплатные онлайн-материалы

* [Learn Python The Hard Way](http://learnpythonthehardway.org/book/)
* [Dive Into Python](http://www.diveintopython.net/)
* [The Official Docs](http://docs.python.org/2.6/)
* [Hitchhiker's Guide to Python](http://docs.python-guide.org/en/latest/)
* [Python Module of the Week](http://pymotw.com/2/)

### Платные

* [Programming Python](http://www.amazon.com/gp/product/0596158106/ref=as_li_qf_sp_asin_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=0596158106&linkCode=as2&tag=homebits04-20)
* [Dive Into Python](http://www.amazon.com/gp/product/1441413022/ref=as_li_tf_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1441413022&linkCode=as2&tag=homebits04-20)
* [Python Essential Reference](http://www.amazon.com/gp/product/0672329786/ref=as_li_tf_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=0672329786&linkCode=as2&tag=homebits04-20)

