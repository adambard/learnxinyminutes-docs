---
language: rust
contributors:
    - ["P1start", "http://p1start.github.io/"]
translators:
    - ["ShaltaevGleb", "https://github.com/ShaltaevGleb"]
filename: learnrust-ru.rs
lang: ru-ru
---

Rust - это язык программирования разрабатываемый Mozilla Research.
Rust комбинирует в себе низкоуровневый контроль c производительностью высокоуровневых языков, обеспечивая при этом безопасность исполнения.

Все это достигается без необходимости сборки мусора и при отсутствии мусора при исполнении, это делает возможным использование библиотек написанных на Rust, как нативных для C.

Первый релиз Rust, 0.1, вышел в Январе 2012, и после в течении 3 лет интенсивной разработки все пользователи были вынуждены использовать ночные сборки, пока не выпустили стабильную версию.

15 Мая 2015, Rust 1.0 был выпушен с полной гарантией обратной совместимости. Было сделано много работы для улучшения времени компиляции и других аспектов компилятора. В Rust принята модель релизов, согласно которой стабильный релиз выходит каждые 6 недель. Rust 1.1 beta стал доступен в то же время что и стабильный релиз 1.0.

И хотя Rust низкоуровневый язык, но в него включены некоторые функциональный концепции ранее присущее в основном высокоуровневым языкам. Это сделало программы на Rust не только быстрыми, но и более простыми и эффективными в разработке и программировании.

```rust
// Так в Rust выглядит комментарий...
// а так достигается мультистрочность.

/// Так выглядят комментарии документации, при этом они поддерживают markdown
/// нотацию
/// # Пример
///
/// ```
/// let five = 5
/// ```

///////////////
// 1. Основы //
///////////////

// Функции
// `i32` это тип 32-битного целого знакового числа
fn add2(x: i32, y: i32) -> i32 {
    // Неявное возвращаемое значение (отсутствует ; )
    x + y
}

// Главная функция
fn main() {
    // Числа //

    // Объявление неизменяемых переменных
    let x: i32 = 1;

    // Суффиксы для Целых/Дробных
    let y: i32 = 13i32;
    let f: f64 = 1.3f64;

    // Интерференция типов
    // В большинстве случаев Rust может самостоятельно вывести тип переменной.
    // Поэтому явное написании не нужно.
    // В этом руководстве, типы указаны во многих местах, но это сделано только
    // в демонстративных целях. В большинстве случает типовая интерференция
    // справится с этим за вас.
    let implicit_x = 1;
    let implicit_f = 1.3;

    // Арифметические операции
    let sum = x + y + 13;

    // Изменяемые (Mutable) переменные
    let mut mutable = 1;
    mutable = 4;
    mutable += 2;

    // Строки //

    // Строковае литералы
    let x: &str = "Привет мир!";

    // Вывод в консоль
    println!("{} :: {}", f, x); // 1.3 :: Привет мир!

    // `Строка` – в куче
    let s: String = "hello world".to_string();

    // Строковый срез – это неизменяемое представление в другой строке
    // В основе лежит неизменяемая пара указателей на строки – 
    // не строки, а только указатель на начало и конец строкового буфера,
    // статически расположенные или содержащиеся в других объектах
    // (в данном случае в `s`)
    let s_slice: &str = &s;

    println!("{} {}", s, s_slice); // Привет мир! Привет мир!

    // Векторы/массивы //

    // Массив с фиксированным размером
    let four_ints: [i32; 4] = [1, 2, 3, 4];

    // Динамический массив - вектор (vector)
    let mut vector: Vec<i32> = vec![1, 2, 3, 4];
    vector.push(5);

    // Срез – неизменяемое представление в векторе или массиве.
    // Это очень похоже на срез строки, но для векторов
    let slice: &[i32] = &vector;

    // Используйте `{:?}` для вывода чего-либо в стиле обработки ошибок (debug)
    println!("{:?} {:?}", vector, slice); // [1, 2, 3, 4, 5] [1, 2, 3, 4, 5]

    // Кортежи //

    // Кортеж фиксированного размера 
    // Набор значений, которые могут быть различных типов
    let x: (i32, &str, f64) = (1, "hello", 3.4);

    // Разбор кортежа в `let`
    let (a, b, c) = x;
    println!("{} {} {}", a, b, c); // 1 hello 3.4

    // Индексация
    println!("{}", x.1); // hello

    /////////////
    // 2. Типы //
    /////////////

    // Структуры
    struct Point {
        x: i32,
        y: i32,
    }

    let origin: Point = Point { x: 0, y: 0 };

    //  Структура с неименованными полями, зовется ‘структура-кортеж’
    struct Point2(i32, i32);

    let origin2 = Point2(0, 0);

    // Базовое "в стиле C" перечисление
    enum Direction {
        Left,
        Right,
        Up,
        Down,
    }

    let up = Direction::Up;

    // Перечисление с полями
    enum OptionalI32 {
        AnI32(i32),
        Nothing,
    }

    let two: OptionalI32 = OptionalI32::AnI32(2);
    let nothing = OptionalI32::Nothing;

    // Денерики (Generics) //

    struct Foo<T> { bar: T }

    // Пример из стандартной библиотеки - `Option`
    enum Optional<T> {
        SomeVal(T),
        NoVal,
    }

    // Методы //

    impl<T> Foo<T> {
        // Метод может принимать специальный параметр `self`
        fn get_bar(self) -> T {
            self.bar
        }
    }

    let a_foo = Foo { bar: 1 };
    println!("{}", a_foo.get_bar()); // 1

    // Типажи (Traits) (известны как интерфейсы в других языках) //

    trait Frobnicate<T> {
        fn frobnicate(self) -> Option<T>;
    }

    impl<T> Frobnicate<T> for Foo<T> {
        fn frobnicate(self) -> Option<T> {
            Some(self.bar)
        }
    }

    let another_foo = Foo { bar: 1 };
    println!("{:?}", another_foo.frobnicate()); // Some(1)

    /////////////////////////////////////
    // 3. Шаблон сопоставления `match` //
    /////////////////////////////////////

    let foo = OptionalI32::AnI32(1);
    match foo {
        OptionalI32::AnI32(n) => println!("значение типа i32: {}", n),
        OptionalI32::Nothing  => println!("Значения Nothing!"),
    }

    // Расширенное сопоставление
    struct FooBar { x: i32, y: OptionalI32 }
    let bar = FooBar { x: 15, y: OptionalI32::AnI32(32) };

    match bar {
        FooBar { x: 0, y: OptionalI32::AnI32(0) } =>
            println!("Числа - 0!"),
        FooBar { x: n, y: OptionalI32::AnI32(m) } if n == m =>
            println!("Одинаковые числа"),
        FooBar { x: n, y: OptionalI32::AnI32(m) } =>
            println!("Отличные числа: {} {}", n, m),
        FooBar { x: _, y: OptionalI32::Nothing } =>
            println!("Второго числа имеет значение Nothing!"),
    }

    ////////////////////////
    // 4. Контроль потока //
    ////////////////////////

    // `for` цикл/итерации
    let array = [1, 2, 3];
    for i in array.iter() {
        println!("{}", i);
    }

    // Области
    for i in 0u32..10 {
        print!("{} ", i);
    }
    // напечптает `0 1 2 3 4 5 6 7 8 9 `

    // `if` (если)
    if 1 == 1 {
        println!("Maths is working!");
    } else {
        println!("Oh no...");
    }

    // `if` как выражение
    let value = if true {
        "good"
    } else {
        "bad"
    };

    // `while` (Цикл Пока)
    while 1 == 1 {
        println!("The universe is operating normally.");
    }

    // Бесконечный цикл
    loop {
        println!("Hello!");
    }

    ////////////////////////////////////////
    // 5. Безопасность памяти & указатели //
    ////////////////////////////////////////

    // Владеть указателем – у данного указателя может быть только один владелец
    // единовременно.
    // Это означает, что когда `Box` покидает область видимости, то значение
    // можно автоматически безопасно удалить из памяти.
    let mut mine: Box<i32> = Box::new(3);
    *mine = 5; // разыменование 
    // Здесь, `now_its_mine` берет во владение `mine`. Другими словами, `mine`
    // перемещается.
    let mut now_its_mine = mine;
    *now_its_mine += 2;

    println!("{}", now_its_mine); // 7
    // println!("{}", mine); // тут будет ошибка компиляции так как
    // сейчас данным указателем владеет `now_its_mine`

    // Ссылка – на неизменный указатель который ссылается на другие данные
    // Когда мы получаем значение по ссылке, мы говорим что значение было
    // ‘заимствовано’.
    // Пока значение заимствовано оно неизменно, не может быть не изменено,
    // не перемещено.
    // Последнее заимствование действует до конца области видимости в которой
    // создано.
    let mut var = 4;
    var = 3;
    let ref_var: &i32 = &var;

    println!("{}", var); // В отличии от `mine`, `var` остается доступным
    println!("{}", *ref_var);
    // var = 5; // Тут будет ошибка компиляции, так как `var` заимствовано
    // *ref_var = 6; // Это не сработает, так как `ref_var` неизменная ссылка

    // Изменяемая ссылка (mutable reference)
    // Пока значение заимствовано с правом изменения, ону будет недоступно вне
    // заимствования.
    let mut var2 = 4;
    let ref_var2: &mut i32 = &mut var2;
    *ref_var2 += 2; // '*' используется для перехода по изменяемому
                    // заимствованию var2

    println!("{}", *ref_var2); // 6 , // var2 не доступно для отображения.
    // ref_var2 имеет тип &mut i32, поэтому хранит ссылку на i32, не значение.
    // var2 = 2; // Тут будет ошибка компиляции, так как `var2` заимствовано.
}
```

## Материалы для дальнейшего изучения

В данном руководстве приведены только базовые основы, которые помогут в понимании Rust. Для более глубокого изучения будут полезны ссылки ниже

En:
  - [The Rust Programming Language](http://doc.rust-lang.org/book/index.html)
  - [subreddit /r/rust](http://reddit.com/r/rust)
  - [Mozzila IRC on #rust cannel](irc.mozilla.org)

Ru:
  - [Русское сообщество](https://rustycrate.ru/)

Множество интересные проекты н написанных на Rust:
  - [RustKit](http://rustkit.io/)

Также вы можете попробовать Rust в официальной онлайн песочнице:
  - [Rust песочница](http://play.rust-lang.org)
  - [Главной странице официального сайта](http://rust-lang.org)
